{"meta":{"title":"cyl's blog","subtitle":"","description":"","author":"yl.chen","url":"https://ysln.github.io","root":"/"},"pages":[],"posts":[{"title":"hello","slug":"hello","date":"2021-05-01T07:41:10.000Z","updated":"2021-05-01T07:41:10.237Z","comments":true,"path":"2021/05/01/hello/","link":"","permalink":"https://ysln.github.io/2021/05/01/hello/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"C语言实现Real-Eval-Print-Loop (REPL)","slug":"crepl","date":"2021-05-01T07:11:46.598Z","updated":"2021-05-01T08:31:06.690Z","comments":true,"path":"2021/05/01/crepl/","link":"","permalink":"https://ysln.github.io/2021/05/01/crepl/","excerpt":"","text":"很多现代编程语言都提供了交互式的REPL, 比如Python. 在REPL中, 除了进行简单的数值计算外(类似计算器), 还可以动态创建函数, 并在之后调用它. 基于”解释执行”的程序设计语言(包括shell本身)天生就具有这种交互式的工作模式. 这个实验的目的是使用C语言实现一个简易的REPL. 最终效果如下: 这个技术和现代虚拟机中的即时编译 (just-in-time) 技术是非常相关的：在程序运行时 (而非程序执行前) 进行编译，并将编译得到的二进制代码 (指令/数据) 动态加载。 — 摘自jyy的实验指南. 分析C语言是一种编译型的语言, 源文件到二进制文件需要经过编译和链接(link)两个过程. 链接主要完成的工作是符号解析和重定位. 如果是静态链接的程序(-static), 类型为Executable file(EXEC), 即可执行文件. 程序中的所有符号都是被完全解析的, 比如所有函数符号的地址都是确定的, 可以直接调用. GCC默认生成的二进制文件是动态链接的, 生成的文件文件类型为Shared object file(DYN). 一个动态链接的程序从磁盘(disk)上刚加载出来时是**不完整(部分链接)**的, 比如程序调用的位于glibc动态链接库中的printf函数地址是未知的. 内核(加载器)不能立即把控制权交给该程序(即跳转到entry). 因此, 需要另外的辅助程序( helper program)的帮助 — dynamic linker, (一般是ld.so). 它的任务是: 加载程序依赖的DSOs(动态链接库, 比如glibc), 并完成重定位(relocation). 因此, 要想实现一个交互式的REPL, 在程序运行时动态的在其地址空间内加入新的函数符号, 本质上是实现动态链接器的功能. 实现C语言实现的REPL的工作流程如下: 读取用户的输入. 把输入的内容写入一个临时的源文件, 并把其编译成一个动态链接库. 把动态链接库加载到进程的地址空间. 计算用户输入的表达式, 输出结果. 重复上述步骤. 编译 这里有以下注意事项: 如果用户输入不是函数, 而是表达式, 比如”5 + 6”, 该怎么办? 一个很自然(看完jyy的实验指南后确实很自然…)的想法是把表达式”包装”(wrap)成一个函数, 比如: 1int __wrap_func() &#123; return 5 + 6;&#125; 这里实现”即时编译”的方法是fork一个子进程, 让子进程执行GCC, 主要是exec函数族(l, v, p, e的组合)的使用, 要注意argv[0]需要为可执行文件的名字. 注意这里把子进程的标准输出和标错误都关闭了, 防止gcc的输出影响. 这里还有一点是如果用户输入”f() + 6”, 那么源文件的内容为: 1int __wrap_func() &#123; return f() + 6;&#125; 此时gcc编译会给出警告: “f”未定义. 如果”f”在之前定义了, 那么这个警告就无关紧要. 就算”f”没有定义, 也没有关系, 可以把出错处理推迟到加载阶段. 加载 可以使用dlopen在运行时加载一个so文件到当前进程的地址空间中. 这里需要注意dlopen的flag参数: RTLD_GLOBAL是必不可少的, 其含义是: 当前加载的so中的符号对其他so可见, 也就是说之后加载的so符号解析时, 可以使用这个so中的符号. 与其相对的是RTLD_LOCAL. 如果去掉RTLD_GLOBAL, 会出现以下这种情况: 注意表达式”f()”也会被”wrap”成一个函数, 并编译成so. RTLD_NOW也是必不可少的, 其含义是: 在加载so时就进行(函数)符号解析. 与之相对的是RTLD_LAZY, 表示对应的函数符号解析推迟到函数被调用时. 使用RTLD_LAZY参数有以下实验现象: 也就是说, 定义函数时可以使用当前还未定义的符号, dlopen时不会报错(因为不会进行符号解析). 但是调用时如果找不到对应的函数符号, 进程会直接crash, 结束运行. 而使用RTLD_NOW参数有以下实验现象: 也就是说定义函数时不允许使用当前还未定义的符号, 也不能直接使用未定义的函数计算, dlopen进行符号解析时就会出错. 因此, 这才是我们想要的行为.","categories":[],"tags":[]}],"categories":[],"tags":[]}