<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Sans Serif:300,300italic,400,400italic,700,700italic|Serif:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Fira Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ysln.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="cyl&#39;s blog">
<meta property="og:url" content="https://ysln.github.io/index.html">
<meta property="og:site_name" content="cyl&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="yl.chen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://ysln.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>cyl's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">cyl's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ysln.github.io/2021/07/11/CMU-database-lab-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yl.chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cyl's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/11/CMU-database-lab-1/" class="post-title-link" itemprop="url">CMU DBMS实验笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-11 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-11T00:00:00+08:00">2021-07-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-28 22:54:13" itemprop="dateModified" datetime="2021-07-28T22:54:13+08:00">2021-07-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMU-DBMS-Lab/" itemprop="url" rel="index"><span itemprop="name">CMU DBMS Lab</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本文是在完成 <strong><a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/fall2020/">卡耐基梅隆大学 数据库实验</a></strong> 过程中的一些记录.</p>
</blockquote>
<blockquote>
<p>如果遇到问题, 可以去 <a href="https://link.zhihu.com/?target=https://discord.gg/YF7dMCg">Discord channel</a> 寻求帮助.</p>
</blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这门课是关于数据库管理系统(DataBase Management Systems, DBMS)的设计与实现. 教学大纲参阅 <a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/fall2020/syllabus.html">SYLLABUS</a>. </p>
<img src="/2021/07/11/CMU-database-lab-1/image-20210704122337806.png" alt="image-20210704122337806" style="zoom: 50%;">

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>数据库(database)是对现实世界的某些方面进行建模的相互关联(inter-related)的数据的有组织(organized)的集合. DBMS是管理database的软件, 用于定义(define), 创建(create), 查询(query), 更新(update)和管理(administrate)数据库.</p>
<p>数据模型(data model)是描述数据库中的数据的概念集合.  <strong>relational model</strong>是其中一种data model, 它主要定义了三种概念:</p>
<ul>
<li><strong>Structure</strong>. 关系(relations)及其内容(content)的定义. 描述了关系(relations)所拥有的属性(attributes)以及这些属性可以拥有的值(values). <em>通俗理解: 数据结构.</em></li>
<li><strong>Integrity</strong>. 确保数据库的内容满足约束. 比如年份(year)必须是一个整数.</li>
<li><strong>Manipulation</strong>. 怎样访问和修改数据库的内容.</li>
</ul>
<p><strong>relation</strong>是一个<strong>无序集合, 包含了一系列的属性</strong>, 用于描述表的条目. A relation with n attributes is called an <strong>n-ary relation</strong>. <del>个人理解: 比如对于描述学生的一个表, relation可以为(name, age, GPA), 这些属性之间是没有顺序的, 也可以按照(GPA, name, age)的形式来存储, 这取决于DBMS的实现, 可以优化(比如内存对齐).</del></p>
<p><strong>tuple</strong>是relation中属性值的集合, 也叫做 <strong>record</strong>. 比如对于上面那个描述学生的表, relation为(name, age, GPA), 那么表示Tony这个学生的tuple为(“Tony”, 23, 3.9). <em>通俗理解: 表的一行(row)</em>.</p>
<blockquote>
<p>怎么理解 <strong>relational model</strong> 是无序的(unordered)? 属性之间无序? 比如 (name, age, GPA) 和 (GPA, name, age). 还是tuple之间无序? 比如 (“Tony”, 23, 3.9) 和 (“cyl”, 23, 3.7) 这两个tuple是无序的.</p>
</blockquote>
<h2 id="PROJECT-0-C-PRIMER"><a href="#PROJECT-0-C-PRIMER" class="headerlink" title="PROJECT #0 - C++ PRIMER"></a>PROJECT #0 - C++ PRIMER</h2><blockquote>
<p><em>Any student that is unable to complete this assignment before the deadline will be asked to drop the course.</em></p>
</blockquote>
<p>这个实验不计入成绩, 只是作为热身, 考察C++的基础知识. 如果无法完成该实验, 建议退课. </p>
<p>这门课程的所有实验都要求使用 modern C++, 最起码C++11, C++17也支持. 课程对编码风格要求很严格, 建议遵从<a target="_blank" rel="noopener" href="https://google.github.io/styleguide/cppguide.html">Google的C++编码规范</a>. 在完成实验之后, 提交代码之前, 需要使用以下命令来格式化代码, 并检查代码是否规范:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make format      <span class="comment"># clang-format</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make check-lint  <span class="comment"># cpplint</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make check-clang-tidy</span></span><br></pre></td></tr></table></figure>

<p>该课程使用 <a target="_blank" rel="noopener" href="https://www.gradescope.com/">Gradescope</a> 作为评测系统, 非CMU学生可以使用这个课程码: 5VX7JZ. 提交代码前, 仔细阅读实验规范, 把指定的文件打包成<code>zip</code>后提交.</p>
<img src="/2021/07/11/CMU-database-lab-1/image-20210711102154382.png" alt="image-20210711102154382" style="zoom:67%;">

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>unique_ptr</code>无法赋值, 但是可以<code>move</code>.</li>
<li><code>Matrix</code>是模板类, <code>RowMatrix</code>是其派生类. <code>RowMatrix</code>如果想要访问<code>Matrix</code>的<code>protected</code>的成员变量, 需要按照这种格式: <code>Matrix&lt;T&gt;::rows</code>.</li>
</ul>
<h2 id="PROJECT-1-BUFFER-POOL"><a href="#PROJECT-1-BUFFER-POOL" class="headerlink" title="PROJECT #1 - BUFFER POOL"></a>PROJECT #1 - BUFFER POOL</h2><h3 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a>实验背景</h3><blockquote>
<p>这个实验, <del>或者说这个课程最终要实现的东西</del> 非常像 <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2012/xv6/book-rev7.pdf">xv6的文件系统</a>, 它甚至也有logging和recovery. <em>说到文件系统, NJU OS的文件系统我到现在只完成了makefs这个工具…</em></p>
<img src="/2021/07/11/CMU-database-lab-1/image-20210710201646108.png" alt="image-20210710201646108" style="zoom: 80%;">

<p><strong>Buffer Cache就相当于PROJECT #1要实现的Buffer Pool.</strong></p>
</blockquote>
<p>这门课主要讨论“disk-oriented” DBMS架构, 即数据库文件持久化存储在非易失( non-volatile)的磁盘上. jyy说过<strong>文件系统是存储在磁盘上的数据结构</strong>, 数据库文件也是如此. 为了操作该数据结构, DBMS需要把它读到物理内存中. 即把数据在磁盘和物理内存之间搬运. 一旦涉及到磁盘I/O, 情况就不是很乐观. 众所周知, 磁盘I/O是非常耗时的:</p>
<img src="/2021/07/11/CMU-database-lab-1/image-20210710221457865.png" alt="image-20210710221457865" style="zoom:50%;">

<p>因此, DBMS提供了Buffer Pool这种机制来减少频繁的磁盘I/O, 其背后的思想就是计算机系统中十分经典且万能的<strong>Cache, 缓存</strong>. </p>
<p>具体做法如下: Buffer Pool维护一片较小的物理内存(比如几百MiB), 作为存储在磁盘上的数据库文件(可能几个GiB)的缓存. 当系统中的其他部分想要读写数据库的数据时, Buffer Pool首先查找Cache中是否已经缓存(通过一个映射表, “页表”), 若缓存命中, 直接返回. 反之, 把磁盘上的数据读到Cache中(必要时需要牺牲Cache中的某些页面, LRU).</p>
<img src="/2021/07/11/CMU-database-lab-1/image-20210710224448826.png" alt="image-20210710224448826" style="zoom:50%;">

<p>等等, 页表, swap-in/swap-out, LRU, 这不就是 <strong>虚拟内存(virtual memory)</strong> 吗? 确实如此, Buffer Pool想要实现的功能, 借助操作系统提供的虚拟内存也能实现, 比如<code>mmap</code>. 也确实有一些数据库是这么做的.</p>
<p>但是这有什么弊端呢? 讲义是这么说的, <em>我不是很理解这个问题</em>:</p>
<img src="/2021/07/11/CMU-database-lab-1/image-20210710222530431.png" alt="image-20210710222530431" style="zoom: 67%;">

<p>考虑到正确性, 性能等原因, DBMS应该自己掌控Cache. 操作系统提供的虚拟内存是一种通用的机制, 以OS的视角来看, 它只知道自己在读写磁盘文件, 对于具体的文件数据类型, OS不知道, 也不关心. 但是DBMS知道数据库文件是什么(因为就是由DBMS来解释数据库文件), 它可以对此提供更精细的控制(<em>比如???</em>).</p>
<blockquote>
<p>老师在课上有如下的比喻: 操作系统提供的虚拟内存好比大卡车, 而DBMS就像跑车.</p>
</blockquote>
<p>此外, 对于磁盘文件的操作都是通过OS提供的文件系统API, 比如<code>read</code>/<code>write</code>, 而<strong>文件系统也有自己的缓存(xv6文件系统的Buffer Cache)</strong>. 但是DBMS通过Buffer Pool来管理数据库文件的缓存. 为了避免冗余的文件副本以及两者不同的页面替换策略带来的影响, <strong>DBMS使用direct I/O绕过操作系统的缓存</strong>.</p>
<blockquote>
<p>在代码里的体现就是<code>sync</code>, <code>fsync</code>, 或者<code>fflush</code>.</p>
</blockquote>
<h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><h4 id="TASK-1-LRU-REPLACEMENT-POLICY"><a href="#TASK-1-LRU-REPLACEMENT-POLICY" class="headerlink" title="TASK #1 - LRU REPLACEMENT POLICY"></a>TASK #1 - LRU REPLACEMENT POLICY</h4><p>Buffer Pool只有有限的物理内存, 当缓存不够, 而又要从磁盘读取新的page到缓存中时, 通过LRU策略来替换最近最少使用的page.</p>
<p>如何体现”最近”和”最少”? 一开始我的想法是为每个page维持两个变量: refcount和timestamp. 当要选择一个victim page时, 选择refcount最小的, 如果refcount相同, 选择timestamp最老的. 但是仔细想想就能发现这种算法是错误的.</p>
<p><strong>其实只需要维持一个timestamp就行. 每当一个page被访问时, 更新该页面的timestamp. 当要选择一个victim page时, 选择timestamp最老的page.</strong> 也就是说, 只需要一个队列就可以达到目的, 当一个page被访问时, 把它移到队列的头部, 当要选择一个victim page时, 从队列尾部移除.</p>
<img src="/2021/07/11/CMU-database-lab-1/image-20210711104011473.png" alt="image-20210711104011473">

<blockquote>
<p>参考资料: <a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/lru-cache-implementation/">LRU Cache Implementation - GeeksforGeeks</a></p>
</blockquote>
<p>需要实现<code>LRUReplacer</code>这个类. 具体实现时选取的数据结构如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::list&lt;<span class="keyword">frame_id_t</span>&gt; unpinned_buffer_;</span><br><span class="line">std::unordered_map&lt;<span class="keyword">frame_id_t</span>, std::pair&lt;<span class="keyword">bool</span>, std::list&lt;<span class="keyword">frame_id_t</span>&gt;::iterator&gt;&gt; lookup_tab_;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>unpinned_buffer_</code>存储当前可以牺牲的frame, 从头部插入, 从尾部移除.</p>
</li>
<li><p><code>lookup_tab_</code>存储当前追踪的所有frame, 包括被pin住的和未被pin住的, key为frame id, value为<code>std::pair</code>, 它的第一个元素的含义是该frame是否被pin住, 第二个元素代表该frame在<code>unpinned_buffer_</code>中的位置(只有当该frame未被pin住才有意义, 因为被pin住的frame会从<code>unpinned_buffer_</code>中移除).</p>
</li>
</ul>
<p>关于frame和page的含义参考下图:</p>
<img src="/2021/07/11/CMU-database-lab-1/image-20210710224448826.png" alt="image-20210710224448826" style="zoom:50%;">

<p>关于pin和unpin这两个操作的含义:</p>
<ul>
<li>pin: 表示接下来我需要读写该frame中的page, 你不能把它替换出去.</li>
<li>unpin: 操作完毕, 你可以把它替换出去(并不表示你现在就要把它替换出去).</li>
</ul>
<p>为什么选择<code>bool</code>来作为frame是否被pin住, 而不是选择<code>int</code>来表示frame的pin count? <strong>由<code>BufferPoolManager</code>来管理page的pin count, 当其pin count为0是, 调用<code>LRUReplacer::Unpin</code>.</strong></p>
<p>注意点:</p>
<ul>
<li>调用<code>LRUReplacer::Unpin</code>来把一个frame交给<code>LRUReplacer</code>追踪.</li>
</ul>
<h4 id="TASK-2-BUFFER-POOL-MANAGER"><a href="#TASK-2-BUFFER-POOL-MANAGER" class="headerlink" title="TASK #2 - BUFFER POOL MANAGER"></a>TASK #2 - BUFFER POOL MANAGER</h4><p>实现<code>BufferPoolManager</code>. 注意点:</p>
<ul>
<li><p>当从磁盘中读取一个<strong>新的page</strong>到Buffer Pool时(<code>BufferPoolManager::FetchPageImpl</code>和<code>BufferPoolManager::NewPageImpl</code>), <strong>需要把该page对应的frame id交给<code>LRUReplacer</code>追踪, 然后把该frame pin住, 并增加该page的pin count</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">replacer_-&gt;<span class="built_in">Unpin</span>(frame_id);  <span class="comment">// unpin it first! add it to replacer!</span></span><br><span class="line">replacer_-&gt;<span class="built_in">Pin</span>(frame_id);    <span class="comment">// pin it via replacer</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>BufferPoolManager::UnpinPageImpl</code>: </p>
<ul>
<li>如果该page不在page table中, 需要返回<code>true</code>. </li>
<li>如果该page的pin count已经为0, 直接返回<code>false</code>.</li>
<li> 如果该page的pin count不为0, 递减pin count, 如果递减后达到0, 需要调用<code>LRUReplacer::Unpin</code>.</li>
</ul>
</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>实验中的数据库文件就是<code>.db</code>文件, 文件按照page组织, 每个page大小为<code>PAGE_SIZE</code>(4096字节). 读写<code>.db</code>文件时, 需要指定page id(从0开始的整数), <code>DiskManager</code>会定位到相应的offset, 读写<code>PAGE_SIZE</code>大小的数据. <em>talk is cheap, show me the code</em>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Write the contents of the specified page into disk file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DiskManager::WritePage</span><span class="params">(<span class="keyword">page_id_t</span> page_id, <span class="keyword">const</span> <span class="keyword">char</span> *page_data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> offset = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(page_id) * PAGE_SIZE;  <span class="comment">// 计算offset</span></span><br><span class="line">  db_io_.<span class="built_in">seekp</span>(offset);  <span class="comment">// set write cursor to offset</span></span><br><span class="line">  db_io_.<span class="built_in">write</span>(page_data, PAGE_SIZE);</span><br><span class="line">  <span class="comment">// 省略一些代码...</span></span><br><span class="line">  db_io_.<span class="built_in">flush</span>();  <span class="comment">// needs to flush to keep disk file in sync</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Read the contents of the specified page into the given memory area</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DiskManager::ReadPage</span><span class="params">(<span class="keyword">page_id_t</span> page_id, <span class="keyword">char</span> *page_data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> offset = page_id * PAGE_SIZE;  <span class="comment">// 计算offset</span></span><br><span class="line">  <span class="comment">// 省略一些代码...</span></span><br><span class="line">  db_io_.<span class="built_in">seekp</span>(offset);  <span class="comment">// set read cursor to offset</span></span><br><span class="line">  db_io_.<span class="built_in">read</span>(page_data, PAGE_SIZE);</span><br><span class="line">  <span class="comment">// 省略一些代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通关截图"><a href="#通关截图" class="headerlink" title="通关截图"></a>通关截图</h3><img src="/2021/07/11/CMU-database-lab-1/image-20210711000433227.png" alt="image-20210711000433227" style="zoom:67%;">

<img src="/2021/07/11/CMU-database-lab-1/image-20210711000151610.png" alt="image-20210711000151610" style="zoom:80%;">

<blockquote>
<p><em>2021/07/28 更新:</em></p>
<img src="/2021/07/11/CMU-database-lab-1/image-20210728222642076.png" alt="image-20210728222642076">
</blockquote>
<h3 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h3><p>gdb调试时, 如果使用<code>layout src</code>无法查看动态链接库的源代码, 首先确保编译时使用了<code>-g</code>或<code>-ggdb</code>选项, 然后在gdb中, 在程序运行之前(<code>r</code>), 使用以下指令:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set directories /Path/To/SourceOfSharedLib</span><br><span class="line">(gdb) set solib-search-path /Path/To/SharedLib</span><br></pre></td></tr></table></figure>

<p>参考: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/37641967/how-to-debug-a-shared-library-using-gdb">How to debug a shared library using GDB?</a></p>
<h3 id="坑"><a href="#坑" class="headerlink" title="坑!"></a>坑!</h3><p><strong>这个实验并不难, 但是GradeScope评测系统太坑了!</strong></p>
<p>代码在本地编译运行没有任何问题, 但是提交到GradeScope之后报错:</p>
<img src="/2021/07/11/CMU-database-lab-1/image-20210711000758745.png" alt="image-20210711000758745" style="zoom:80%;">

<p>一点可用的调试信息也没有. 我用尽了各种方法, 提交了40次, 几乎都是这样. 我不知道是编译没通过, 还是运行时crash, 还是运行超时. 但我在本地明明可以编译运行通过, 而且代码格式也检查了. </p>
<p>直到我看到这个帖子: <a target="_blank" rel="noopener" href="https://discord.com/channels/724929902075445281/752767235600285797/796269492636090408">p1-2020-buffer_pool_manager (discord.com)</a></p>
<p><img src="/2021/07/11/CMU-database-lab-1/image-20210711001323309.png" alt="image-20210711001323309"></p>
<p>而正巧我也使用了这个语法…但是当我修改之后, GradeScope还是报同样的错误…</p>
<p>然后我看到一个帖子说可以在初始代码的基础上, 一点一点添加代码, 直到GradeScope报错. 然后定位到了这里:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret-&gt;second = &#123;<span class="literal">false</span>, unpinned_buffer_.<span class="built_in">begin</span>()&#125;;</span><br></pre></td></tr></table></figure>

<p>无语…以后还是<strong>少用些语法糖</strong>.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ysln.github.io/2021/07/11/CS144-network-lab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yl.chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cyl's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/11/CS144-network-lab/" class="post-title-link" itemprop="url">CS144 Lab Assignments 实验笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-11 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-11T00:00:00+08:00">2021-07-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-28 22:24:05" itemprop="dateModified" datetime="2021-07-28T22:24:05+08:00">2021-07-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS144-Network-Lab/" itemprop="url" rel="index"><span itemprop="name">CS144 Network Lab</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本文是在完成 <strong><a target="_blank" rel="noopener" href="https://cs144.github.io/">斯坦福大学 CS144课程实验</a></strong> 过程中的一些记录.</p>
</blockquote>
<blockquote>
<p>这个实验我做的不是很好, 只是为了做实验, 而没有去看老师的上课视频, 也没有重新去看 <strong>计算机网络-自顶向下方法</strong> 这本书. <em>这本书当时看了一半就放在一旁, 吃了一年的灰.</em> 并且做实验也有点是面向测试用例的感觉, 并没有仔细的思考 TCP的原理. </p>
</blockquote>
<p>课程目标: 实现 Internet中的几个重要的部分:</p>
<ul>
<li><strong>TCP协议</strong>. 重点.</li>
<li>network interface.</li>
<li>router.</li>
</ul>
<p>课程要求: 使用 modern C++.</p>
<p><img src="/2021/07/11/CS144-network-lab/image-20210628220658616.png" alt="image-20210628220658616"></p>
<blockquote>
<p>这门课程总共有7个实验, 后面的实验会用到前面的实验已经实现好的功能. Lab 0-4是重点和难点, 实现 TCP协议. Lab 5-6相对就更简单些, 实现底层的 network interface和 router.</p>
<p>完成全部实验大概花了一个月左右的时间, 98%的时间都花在了 Lab 0-4上, 中间有一段时间调试到自闭.</p>
</blockquote>
<h2 id="Lab-0-networking-warmup"><a href="#Lab-0-networking-warmup" class="headerlink" title="Lab 0: networking warmup"></a>Lab 0: networking warmup</h2><h3 id="任务1-webget"><a href="#任务1-webget" class="headerlink" title="任务1: webget"></a>任务1: webget</h3><p>使用 <code>HTTP GET</code>从服务器获取 Web 页面. <code>TCPSocket</code>是一个对操作系统提供的TCP socket的 wrapper.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_URL</span><span class="params">(<span class="keyword">const</span> string &amp;host, <span class="keyword">const</span> string &amp;path)</span> </span>&#123;</span><br><span class="line">    TCPSocket sock&#123;&#125;;</span><br><span class="line">    sock.<span class="built_in">connect</span>(Address&#123;host, <span class="string">&quot;http&quot;</span>&#125;);</span><br><span class="line">    sock.<span class="built_in">write</span>(<span class="string">&quot;GET &quot;</span> + path + <span class="string">&quot; HTTP/1.1\r\n&quot;</span> + <span class="string">&quot;Host: &quot;</span> + host + <span class="string">&quot;\r\n\r\n&quot;</span>);</span><br><span class="line">    sock.<span class="built_in">shutdown</span>(SHUT_WR);  <span class="comment">// important!!!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!sock.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; sock.<span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//while (true) &#123;</span></span><br><span class="line">    <span class="comment">//    auto recvd = sock.read();</span></span><br><span class="line">    <span class="comment">//    if (recvd.size() == 0) break;</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; recvd;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    sock.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是, socket表示的是双向的数据流. 在这里, 当发送完 GET请求之后, 就不需要再发送数据了, 而只是接受服务器的响应数据. 因此, 可以关闭 socket的写端 <code>sock.shutdown(SHUT_WR);</code>. 如果去掉这句, 则需要等待大约30秒才会跳出 <code>while</code>循环.</p>
<h3 id="任务2-An-in-memory-reliable-byte-stream"><a href="#任务2-An-in-memory-reliable-byte-stream" class="headerlink" title="任务2: An in-memory reliable byte stream"></a>任务2: An in-memory reliable byte stream</h3><p>实现 <code>ByteStream</code>, 它是一个字节流, 可以往一端写, 从另一端读. <strong>字节流是有限容量的, 但它同时又是”无穷的”</strong>: 即使字节流的容量为1个字节, 只要用户从读端取走数据, 则用户又可以从写端写数据, 直到用户主动终止输入 <code>end_input</code>或者发生某种错误 <code>set_error</code>.</p>
<p>一开始我使用 <code>std::deque&lt;char&gt;</code>作为 <code>ByteStream</code>的内部存储容器. 最终完成Lab4之后, 测试TCP的性能, 吞吐量能达到 1.7Gbit/s.</p>
<img src="/2021/07/11/CS144-network-lab/image-20210626183256880.png" alt="image-20210626183256880" style="zoom:80%;">

<p><a target="_blank" rel="noopener" href="https://cs144.github.io/assignments/lab4.pdf">讲义</a>上的参考数据如下:</p>
<img src="/2021/07/11/CS144-network-lab/image-20210626183501427.png" alt="image-20210626183501427" style="zoom:80%;">

<p>我的实现似乎也还行. 之后看<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kangyupl/p/stanford_cs144_labs.html">网上的一些资料</a>时, 发现可以使用 <code>BufferList</code>类来作为<code>ByteStream</code>的容器, 从而优化 TCP的性能.</p>
<p><code>BufferList</code>的内部使用 <code>std::deque&lt;Buffer&gt;</code>作为容器. <code>Buffer</code>是一种<strong>引用计数的只读的</strong>字符串, <strong>可以从头部丢弃字符</strong>, 类似于<code>std::string_view</code>, 也类似于 Rust的切片 <code>slice</code>.</p>
<p>从 <code>ByteStream</code>的读端读取数据时, 需要把其内部容器的头部移除字符. 而 <code>Buffer</code>从头部丢弃字符是一个非常廉价的操作, 可以在常数时间内完成. </p>
<p>使用 <code>std::deque&lt;char&gt;</code>, 用 gprof分析 tcp_benchmark的数据如下:</p>
<blockquote>
<p>要想使用 gprof分析程序, 需要添加 <code>-pg</code>编译选项.</p>
</blockquote>
<p><img src="/2021/07/11/CS144-network-lab/image-20210626192056124.png" alt="image-20210626192056124"></p>
<p>可以发现 <code>ByteStream</code>的 <code>read</code>和 <code>write</code>花费了较多的时间.</p>
<p>使用 <code>BufferList</code>优化后的 gporf数据如下:</p>
<img src="/2021/07/11/CS144-network-lab/image-20210626193318753.png" alt="image-20210626193318753" style="zoom:80%;">

<p>吞吐量数据如下:</p>
<img src="/2021/07/11/CS144-network-lab/image-20210626193726343.png" alt="image-20210626193726343" style="zoom:80%;">

<h2 id="Lab-1-stitching-substrings-into-a-byte-stream"><a href="#Lab-1-stitching-substrings-into-a-byte-stream" class="headerlink" title="Lab 1:  stitching substrings into a byte stream"></a>Lab 1:  stitching substrings into a byte stream</h2><p>TCP提供<strong>可靠数据传输服务(reliable data transfer)</strong>, 它保证数据正确, 按序交付. 但是底层的网络可能只是提供<strong>尽力而为交付服务(best-effort delivery service)</strong>, 也就是说, 它传输的数据包可能<strong>丢失(loss), 乱序(reordered), 被篡改(altered), 重复到达(duplicated).</strong></p>
<img src="/2021/07/11/CS144-network-lab/image-20210626211803871.png" alt="image-20210626211803871" style="zoom:80%;">

<p>TCP socket有两个方向的字节流, outbound 即 <code>TCPSender</code>, inbound 即 <code>TCPReceiver</code>. 这个实验需要实现一个<strong>字节流重组器</strong> <code>StreamReassembler</code>, 它是 <code>TCPReceiver</code>的一部分. </p>
<p>TCP提供的是一种字节流服务, 其发送的每一个字节数据都在字节流中占据一个独特的序号. <code>TCPSender</code>从字节流中取出一个片段, 称为 <code>segment</code>, 把它发送给对端(peer). 对端的 <code>TCPReceiver</code>把收到的 <code>segment</code>输入给字节流重组器, 字节流重组器会把这些片段组装成连续字节流, 就和对端发送的一样.</p>
<p><code>StreamReassembler</code>的主要需要实现的接口如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_substring</span><span class="params">(<span class="keyword">const</span> string &amp;data, <span class="keyword">const</span> <span class="keyword">uint64_t</span> index, <span class="keyword">const</span> <span class="keyword">bool</span> eof)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>data</code>是一个字节片段, <code>index</code>表示的是 <code>data</code>的第一个字节在整个字节流中占据的序号, <code>eof</code>表示 <code>data</code>的最后一个字节是否为整个字节流的最后一个字符, 表示流结束了.</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><code>StreamReassembler</code>也有一个容量, 含义如下:</p>
<img src="/2021/07/11/CS144-network-lab/image-20210626215417102.png" alt="image-20210626215417102" style="zoom:80%;">

<p>已经重组但未被用户读取的字节数(上图绿色部分), 已经接收但未被重组的字节数(上图红色部分), 两者之和不能超过 <code>StreamReassembler</code>的容量.</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ByteStream _output;  <span class="comment">// The reassembled in-order byte stream</span></span><br><span class="line"><span class="keyword">size_t</span> _capacity;    <span class="comment">// The maximum number of bytes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The fragments that not yet been reassembled    </span></span><br><span class="line">std::map&lt;<span class="keyword">uint64_t</span>, std::string&gt; _suspend_buf&#123;&#125;;  </span><br><span class="line"><span class="keyword">size_t</span> _next&#123;&#125;;  <span class="comment">// The index of next byte in the stream</span></span><br><span class="line"><span class="keyword">size_t</span> _last&#123;<span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt; (<span class="number">-1</span>)&#125;;  <span class="comment">// The last byte in the entire stream =&gt; EOF</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>std::map</code>作为内部缓存乱序字节片段的容器 <code>_suspend_buf</code>, key为字节片段首字节的序号. 并且维护 <code>_next</code>, 表示当前想要的下一个字节的序号. 维护 <code>_last</code>的原因是: 有可能字节流最后的片段先到达了, 但它并不是此时我们想要的, 当前面空缺的片段到齐之后, 需要终结字节流.</p>
<p><code>_suspend_buf</code>中挂起的字节片段不能重叠(overlap), 比如下面两个片段:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2                     4</span><br><span class="line">+---+---+---+---+     +---+---+---+---+ </span><br><span class="line">| c | d | e | f |     | e | f | g | h |</span><br><span class="line">+---+---+---+---+     +---+---+---+---+</span><br></pre></td></tr></table></figure>

<p>需要合并成一个片段:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">+---+---+---+---+---+---+</span><br><span class="line">| c | d | e | f | g | h |</span><br><span class="line">+---+---+---+---+---+---+</span><br></pre></td></tr></table></figure>

<p>需要注意:</p>
<ul>
<li>如果当前 <code>StreamReassembler</code>的容量已满, 且 <code>_suspend_buf</code>中还有未被重组的字节片段. <strong>但是此时到达了一个我们想要的字节片段(<code>index &lt;= _next</code>), 需要优先把该字节片段写入到 <code>_output</code>.</strong> 然后从 <code>_suspend_buf</code>的尾部开始, 移除超过容量的字节数.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> string &amp;data, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">size_t</span> index, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">bool</span> eof</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_output.<span class="built_in">input_ended</span>() || _output.<span class="built_in">error</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (eof) &#123;</span><br><span class="line">        _last = index + data.<span class="built_in">size</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt;= _next) &#123;</span><br><span class="line">        <span class="built_in">commit</span>(data, index);  <span class="comment">// 写入到 _output</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">suspend</span>(data, index);  <span class="comment">// 添加到 _suspend_buf</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = _suspend_buf.<span class="built_in">begin</span>(); iter != _suspend_buf.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;first &gt; _next) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">commit</span>(iter-&gt;second, iter-&gt;first);</span><br><span class="line">        _unassembled_bytes -= iter-&gt;second.<span class="built_in">size</span>();</span><br><span class="line">        iter = _suspend_buf.<span class="built_in">erase</span>(iter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果当前未读取和未装配的字节数加起来超过了容量, 移除map末尾的溢出数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (_unassembled_bytes + _output.<span class="built_in">buffer_size</span>() &gt; _capacity) &#123;</span><br><span class="line">        <span class="built_in">remove</span>(_unassembled_bytes + _output.<span class="built_in">buffer_size</span>() - _capacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lab-2-the-TCP-receiver"><a href="#Lab-2-the-TCP-receiver" class="headerlink" title="Lab 2: the TCP receiver"></a>Lab 2: the TCP receiver</h2><img src="/2021/07/11/CS144-network-lab/image-20210626211803871.png" alt="image-20210626211803871" style="zoom: 67%;">

<p><code>TCPReceiver</code>的职能是把 incoming TCP segments 转换成 incoming bytes stream. 除此之外, 它还需要告诉<strong>本端</strong>的<code>TCPSender</code>两件事情:</p>
<img src="/2021/07/11/CS144-network-lab/image-20210626215417102.png" alt="image-20210626215417102" style="zoom: 67%;">

<ul>
<li><strong>acknowledgment number (<code>ackno</code>)</strong>. 它的含义是: <code>TCPReceiver</code>希望从<strong>对端</strong>的 <code>TCPSender</code>获取的<strong>下一个字节序号</strong>. 相当于上图中的 “first unassembled”. </li>
<li><strong>window size (<code>win</code>)</strong>. 表示 “first unassembled” 与 “first unacceptable” 之间的距离.</li>
</ul>
<p><code>ackno</code> 和 <code>win</code>共同描述了 <code>TCPReceiver</code>的窗口, <code>TCPReceiver</code>使用这个窗口来控制<strong>对端</strong>发送的流: 只允许<strong>对端</strong>的 <code>TCPSender</code>发送序号大于等于 <code>ackno</code>, 且小于 <code>ackno + win</code>的字节. </p>
<p>数据不断的到达, 窗口也在不断的向右滑动, 这便是著名的<strong>滑动窗口</strong> (<em>是吗?</em>).</p>
<img src="/2021/07/11/CS144-network-lab/image-20210620161545407.png" alt="image-20210620161545407" style="zoom: 33%;">

<h3 id="Translating-between-64-bit-indexes-and-32-bit-seqnos"><a href="#Translating-between-64-bit-indexes-and-32-bit-seqnos" class="headerlink" title="Translating between 64-bit indexes and 32-bit seqnos"></a>Translating between 64-bit indexes and 32-bit seqnos</h3><p>字节流重组器 <code>StreamReassembler</code>使用的 index是64位的, 而 TCP header中的 seqno是32位的. 这部分实验的任务是实现 64位 index与32位 seqno之间的转换.</p>
<img src="/2021/07/11/CS144-network-lab/image-20210626232831255.png" alt="image-20210626232831255" style="zoom: 80%;">

<blockquote>
<p>由于我的数学思维实在太糟糕, 这部分代码我修修改改了很久都没有通过测试用例. 最后不得已参考了网上的资料, 实在是惭愧.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">unwrap</span><span class="params">(WrappingInt32 n, WrappingInt32 isn, <span class="keyword">uint64_t</span> checkpoint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pre = checkpoint &amp; (~<span class="number">0xffffffff</span>lu);</span><br><span class="line">    <span class="keyword">uint64_t</span> num;</span><br><span class="line">    <span class="keyword">if</span> (n.<span class="built_in">raw_value</span>() &gt;= isn.<span class="built_in">raw_value</span>()) &#123;</span><br><span class="line">        num = n.<span class="built_in">raw_value</span>() - isn.<span class="built_in">raw_value</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        num = UINT32_MAX + <span class="number">1lu</span> + n.<span class="built_in">raw_value</span>() - isn.<span class="built_in">raw_value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint64_t</span> a = pre + num;</span><br><span class="line">    <span class="keyword">uint64_t</span> b = a + (UINT32_MAX + <span class="number">1lu</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> c = a - (UINT32_MAX + <span class="number">1lu</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ABS = [] (<span class="keyword">uint64_t</span> x, <span class="keyword">uint64_t</span> y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) <span class="keyword">return</span> x - y;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> y - x;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ABS</span>(a, checkpoint) &lt; <span class="built_in">ABS</span>(b, checkpoint)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ABS</span>(a, checkpoint) &lt; <span class="built_in">ABS</span>(c, checkpoint)) &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现-TCPReceiver"><a href="#实现-TCPReceiver" class="headerlink" title="实现 TCPReceiver"></a>实现 <code>TCPReceiver</code></h3><p><code>TCPReceiver</code>的工作逻辑如下:</p>
<ol>
<li>从对端接收 <code>TCPSegment</code>.</li>
<li>使用 <code>StreamReassembler</code>重组字节流.</li>
<li>计算<strong>应答序列号(<code>ackno</code>)和窗口大小(<code>win</code>)</strong>. <code>ackno</code>和 <code>win</code>最终会通过本端的 <code>TCPSender</code>发送给对端.</li>
</ol>
<img src="/2021/07/11/CS144-network-lab/image-20210627000339211.png" alt="image-20210627000339211" style="zoom:80%;">

<p>主要实现下面这个接口:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">segment_received</span><span class="params">(<span class="keyword">const</span> TCPSegment &amp;seg)</span></span>;</span><br></pre></td></tr></table></figure>

<img src="/2021/07/11/CS144-network-lab/image-20210627001115952.png" alt="image-20210627001115952" style="zoom:80%;">

<p><code>segment_received</code>主要关注 <code>TCPSegment</code>的 <code>seqno</code>, <code>SYN</code>与<code>FIN</code>标志位, <code>payload</code>. </p>
<p>需要注意的是, 出现下面两种情况需要丢弃接收到的 <code>TCPSegment</code>:</p>
<img src="/2021/07/11/CS144-network-lab/image-20210627004921821.png" alt="image-20210627004921821" style="zoom:67%;">

<p>TCP的 <code>SYN</code>和 <code>FIN</code>标志位都占据了字节流中的一个序号, 并且 <code>SYN</code>的绝对序号一定为0. </p>
<h2 id="Lab-3-the-TCP-sender"><a href="#Lab-3-the-TCP-sender" class="headerlink" title="Lab 3: the TCP sender"></a>Lab 3: the TCP sender</h2><img src="/2021/07/11/CS144-network-lab/image-20210626211803871.png" alt="image-20210626211803871" style="zoom: 67%;">

<p><code>TCPSender</code>从 <code>ByteStream</code>(由上层应用创建并且往里面写数据)读数据, 把读取到的字节流切分为一个个有序的 <code>TCPSegment</code>, 发送给对端.</p>
<p><code>TCPSender</code>的具体职责为:</p>
<ul>
<li>追踪<strong>对端的接收窗口</strong>(通过 <code>ackno</code>和 <code>win</code>).</li>
<li>Fill the window. 从 <code>ByteStream</code>里读取数据, 并发送出去, 直到从 <code>ByteStream</code>里没有数据, 或者<strong>对端的接收窗口已经被填满</strong>.</li>
<li>追踪哪些 segment已经发送出去, 但是还没有被对端应答(acknowledged).</li>
<li>如果定时器超时, 重传未被应答的 segment.</li>
</ul>
<p>需要注意的是 “fill the window”这一步, <code>TCPSender</code>总是应该<strong>发送尽可能多的数据去填满它看到的对端的接收窗口</strong>, 并且一直重传丢失的 segment, 直到对端应答所有的 segment. 这被称为 <strong>“automatic repeat request” (ARQ)</strong>.</p>
<p>TCP使用的是<strong>累计应答</strong>机制, 也就是说: 如果对端发送(回应)一个<code>ackno</code>为100的数据包, 表示对端已经接收到了序号为100之前的所有字节(<strong>不包括100</strong>), 对端希望本端的 <code>TCPSender</code>发送序号为100之后的数据(<strong>包括100</strong>).</p>
<img src="/2021/07/11/CS144-network-lab/image-20210620161647505.png" alt="image-20210620161647505" style="zoom: 33%;">

<p>上图中的 <code>SWS</code>其实可以简单理解为 <code>TCPSender</code>看到的<strong>对端的接收窗口大小</strong> <code>win</code>, <code>LAR</code>可以简单理解为 <code>ackno</code>.</p>
<p>这里有一个问题: 如果对端回复其接收窗口大小为0, 该怎么办?</p>
<img src="/2021/07/11/CS144-network-lab/image-20210627023248631.png" alt="image-20210627023248631" style="zoom: 67%;">

<h3 id="实现-TCPSender"><a href="#实现-TCPSender" class="headerlink" title="实现 TCPSender"></a>实现 <code>TCPSender</code></h3><img src="/2021/07/11/CS144-network-lab/1608954-20200914214818554-10014625.png" alt="img" style="zoom:80%;">

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::deque&lt;TCPSegment&gt; _segments_nonack&#123;&#125;;  <span class="comment">// segments that alreadly sent but non-ack</span></span><br><span class="line"><span class="keyword">uint64_t</span> _next_seqno&#123;<span class="number">0</span>&#125;;  <span class="comment">// the (absolute) sequence number for the next byte to be sent</span></span><br><span class="line"><span class="keyword">uint64_t</span> _recver_ackno&#123;&#125;;  <span class="comment">// ackno</span></span><br><span class="line"><span class="keyword">uint64_t</span> _recver_wndsz&#123;&#125;;  <span class="comment">// win</span></span><br><span class="line">RetxTimer _timer&#123;&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> _consecutive_retx&#123;&#125;;  <span class="comment">// 连续重传的次数, 在Lab4会用到</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>std::deque&lt;TCPSegment&gt; _segments_nonack</code>来追踪已发送但未被 ACK的 segment. 当定时器超时, 重传最早发送但未 ACK的 segment(如果有的话), 也就是 <code>_segments_nonack</code>的头部数据, 并根据情况, 让 <strong>retransmission timeout (RTO)</strong> 翻倍:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPSender::tick</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_timer.<span class="built_in">expires</span>(ms_since_last_tick)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_segments_nonack.<span class="built_in">empty</span>()) &#123;  <span class="comment">// 所有segment都被ACK</span></span><br><span class="line">        _timer.<span class="built_in">stop</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ++_consecutive_retx;  <span class="comment">// 连续重传次数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> seg = _segments_nonack.<span class="built_in">front</span>();</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rto = _initial_retransmission_timeout;</span><br><span class="line">    <span class="comment">/* 如果对端的窗口大小为0, 不需要使RTO翻倍 */</span></span><br><span class="line">    <span class="keyword">if</span> (_recver_wndsz != <span class="number">0</span> || seg.<span class="built_in">header</span>().syn) &#123; </span><br><span class="line">        <span class="comment">/* Double the value of RTO */</span></span><br><span class="line">        rto &lt;&lt;= _consecutive_retx;</span><br><span class="line">    &#125;</span><br><span class="line">    _segments_out.<span class="built_in">push</span>(std::<span class="built_in">move</span>(seg));  <span class="comment">// 重传</span></span><br><span class="line">    _timer.<span class="built_in">run</span>(rto);  <span class="comment">// 启动定时器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于定时器启动/停止的时机参考 <strong>计算机网络-自顶向下方法</strong>:</p>
<img src="/2021/07/11/CS144-network-lab/image-20210627024828072.png" alt="image-20210627024828072" style="zoom:67%;">

<p>对于 <code>ack_received</code>函数, 需要验证 <code>ackno</code>的有效性.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPSender::ack_received</span><span class="params">(<span class="keyword">const</span> WrappingInt32 ackno, <span class="keyword">const</span> <span class="keyword">uint16_t</span> window_size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> abs_ackno = <span class="built_in">unwrap</span>(ackno, _isn, _recver_ackno);</span><br><span class="line">    <span class="keyword">if</span> (abs_ackno &gt; _next_seqno) &#123;  <span class="comment">// 如果ACK未发送的数据, 忽略它</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _recver_wndsz = window_size;  <span class="comment">// new window size</span></span><br><span class="line">    <span class="keyword">if</span> (abs_ackno &lt;= _recver_ackno) &#123;  <span class="comment">// 如果重复ACK, 也忽略它</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _recver_ackno = abs_ackno;  <span class="comment">// new ACK</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lab-4-实现完整的-TCP协议"><a href="#Lab-4-实现完整的-TCP协议" class="headerlink" title="Lab 4: 实现完整的 TCP协议"></a>Lab 4: 实现完整的 TCP协议</h2><img src="/2021/07/11/CS144-network-lab/image-20210627030653507.png" alt="image-20210627030653507" style="zoom:67%;">

<p>完整的TCP状态机转换图如下, 如果理解了这个图, 完成这个实验基本上不成问题:</p>
<p><img src="/2021/07/11/CS144-network-lab/1608954-20200914214827124-2104730079.png" alt="img"></p>
<p>这个实验需要把 <code>TCPSender</code>和 <code>TCPReceiver</code>组合起来, 完成 <code>TCPConnection</code>. 这个实验的主要难点是<strong>连接的关闭这部分</strong>, 以及前面几个实验的 BUG修复.</p>
<blockquote>
<p>虽然之前 <code>TCPSender</code>和 <code>TCPReceiver</code>的测试用例(unit tests)全部通过了, 但是在这个实验中, 完整的集成测试(integration tests)通过不了. 因此, 花了比较多的时间来 gdb调试.</p>
<p>最主要的问题是, 当时<strong>关闭连接这部分没有处理好</strong>, 虽然关于状态机的转换的测试用例可以通过(我也很奇怪为什么关于close的测试用例能通过…), 但是真正使用我的TCP实现来传输数据(有概率丢包)时, 总是会发生某些测试用例一会可以通过, 一会又无法通过.</p>
</blockquote>
<h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><p>关闭连接分为两种情况:</p>
<ul>
<li>unclean shutdown. 收到或发送一个 <code>RST</code>标志位置1的 segment, 表示连接状态错误, 需要立刻关闭连接. 当连续重传次数大于某个阈值时, 需要发送 <code>RST</code>.</li>
<li>clean shutdown. 最普遍和复杂的情况.</li>
</ul>
<p>clean shutdown又分为两种情况:</p>
<ul>
<li><p>passive close. <strong>如果 <code>TCPConnection</code>在发送 <code>FIN</code>之前, 就接收到了对端发送的 <code>FIN</code>, 则进入passive close状态.</strong></p>
<img src="/2021/07/11/CS144-network-lab/image-20210627034401032.png" alt="image-20210627034401032" style="zoom:67%;"></li>
<li><p>active close. <strong>如果 <code>TCPConnection</code>在接收到对端发送的 <code>FIN</code>之前, 就已经发送了 <code>FIN</code>, 则进入active close状态.</strong></p>
<img src="/2021/07/11/CS144-network-lab/image-20210627034630990.png" alt="image-20210627034630990" style="zoom:67%;"></li>
</ul>
<blockquote>
<p>为什么需要 <code>TIME_WAIT</code>状态?</p>
<p>TCP并不会响应 ACK数据包(ack ACKs), 有可能 ACK会丢失. 因此, 在 <code>TIME_WAIT</code>等待的这段时间里, <code>TCPConnection</code>可以 <del>响应对端重传</del> 响应对端请求重传的数据.</p>
<img src="/2021/07/11/CS144-network-lab/image-20210627035513212.png" alt="image-20210627035513212" style="zoom:67%;">
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPConnection::check_close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_active_close &amp;&amp; !_passive_close) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_sender.<span class="built_in">sent_fin</span>()) &#123;  <span class="comment">// active close</span></span><br><span class="line">            _active_close = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_receiver.<span class="built_in">closed</span>()) &#123;  <span class="comment">// passive close</span></span><br><span class="line">            _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">            _passive_close = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* passive close */</span></span><br><span class="line">    <span class="keyword">if</span> (_passive_close &amp;&amp; _sender.<span class="built_in">sent_fin</span>() &amp;&amp; _sender.<span class="built_in">bytes_in_flight</span>() == <span class="number">0</span>) &#123;  </span><br><span class="line">        _active = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* active close */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (_active_close &amp;&amp; _receiver.<span class="built_in">closed</span>() &amp;&amp; _sender.<span class="built_in">bytes_in_flight</span>() == <span class="number">0</span> &amp;&amp; </span><br><span class="line">             !_time_wait) &#123; </span><br><span class="line">        _time_wait = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><img src="/2021/07/11/CS144-network-lab/image-20210627040111623.png" alt="image-20210627040111623" style="zoom:67%;">

<p>测试机器: Intel(R) Core(TM) i5-6300HQ CPU @ 2.30GHz. 操作系统: 5.4.0-74-generic #83~18.04.1-Ubuntu. 最终的benchmark数据如下:</p>
<img src="/2021/07/11/CS144-network-lab/image-20210627040217121.png" alt="image-20210627040217121" style="zoom:80%;">

<blockquote>
<p><em>2021/07/28 更新</em>:</p>
<p>由于之前的电脑坏了, 完全开不了机(之前进了两次水…), 所以买了一个新的电脑. 处理器为 <strong>AMD Ryzen 7 5800H</strong>, 8核16线程, 基准频率3.20 GHz. 我拿到机器的第一个念头就是跑一下tcp benchmark, 结果如下:</p>
<img src="/2021/07/11/CS144-network-lab/image-20210728204548324.png" alt="image-20210728204548324" style="zoom:80%;">

<p><strong>AMD yes!!!</strong></p>
</blockquote>
<h2 id="Lab-5-the-network-interface"><a href="#Lab-5-the-network-interface" class="headerlink" title="Lab 5: the network interface"></a>Lab 5: the network interface</h2><p>前面的实验中已经实现了用户空间的 TCP协议, 但是怎么通过我们实现的 TCP协议把数据发送到真实的网络中去? 有以下几种方式:</p>
<ul>
<li>TCP-in-UDP-in-IP. 借助 Linux网络协议栈中的 UDP, 把 TCP分片作为 UDP数据包的 payload. 由 Linux网络协议栈添加 UDP header, IP header, Ethernet header, 然后发送出去.</li>
<li>TCP-in-IP. 直接把 TCP分片作为 IP数据包的payload, 即经典的 <strong>TCP/IP</strong>. 需要应用程序添加完整的 IP header, 并且需要借助 Linux提供的 TUN device.</li>
<li>TCP-in-IP-in-Ethernet. 应用程序添加完整的 IP header, Ethernet header, 不依赖 Linux网络协议栈. 不过需要借助 Linux提供的 TAP device.</li>
</ul>
<p>network interface的作用: <strong>实现 IP数据包和 Ethernet帧之间的转换</strong>, 并且提供 <strong>IP地址和 Ethernet地址(即MAC地址)之间的映射</strong>, 如果某个映射未知, 通过 <strong>Address Resolution Protocol (ARP)</strong> 来获取该映射.</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>主要实现以下三个接口:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_datagram</span><span class="params">(<span class="keyword">const</span> InternetDatagram &amp;dgram, <span class="keyword">const</span> Address &amp;next_hop)</span></span>;</span><br><span class="line"><span class="function">std::optional&lt;InternetDatagram&gt; <span class="title">recv_frame</span><span class="params">(<span class="keyword">const</span> EthernetFrame &amp;frame)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NetworkInterface::tick</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> ms_since_last_tick)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当要发送一个 IP数据报时, 调用 <code>send_datagram</code>. <code>next_hop</code>指示这个数据报下一跳发送到哪里, <strong>注意它并不表示这个数据报最终要送达的目的 IP地址.</strong> network interface内部需要维护一个 IP地址和 Ethernet地址之间的映射表:</p>
<ul>
<li><p>如果 <code>next_hop</code>在映射表中, 则直接把该 IP数据报封装成 Ethernet帧, 发往 <code>next_hop</code>映射到的 Ethernet地址.</p>
</li>
<li><p>如果 <code>next_hop</code> 不在映射表中, 则<strong>通过 ARP广播查询 <code>next_hop</code>映射到的 Ethernet地址(ARP request message), 并且把该 IP数据报缓存起来</strong>, 等知道其下一跳的 Ethernet地址之后再发送.</p>
<blockquote>
<p>这里有一个坑点: 如果已经发送了 ARP request message, 但是还没有得到回复, 并且现在通过 <code>send_datagram</code>发送的数据报的下一跳的 Ethernet地址也是未知的, 那么<strong>不需要再次发送 ARP request message, 直接缓存该 IP数据报, 等前一个 ARP request message得到回复之后, 再发送新的 ARP request message</strong>. 也就是说, <strong>最多同时发送一个 ARP request message</strong>. </p>
<p>相当于<strong>停等</strong>, 而不是像 TCP一样的流水线.</p>
</blockquote>
</li>
</ul>
<p>当接收到一个 Ethernet帧时, 调用 <code>recv_frame</code>. 注意需要忽略所有目标不是本 network interface的 Ethernet帧. </p>
<ul>
<li>如果 Ethernet帧的 payload是 IP数据报, 直接把 IP数据报返回.</li>
<li>如果 Ethernet帧的 payload是 <strong>ARP reply/request message</strong>. 把 IP地址和 Ethernet地址之间的映射关系缓存到映射表里. 并且发送缓存的 IP数据报中可以发送的那些. 如果是 request 本 network interface, 发送 ARP reply message回去.</li>
</ul>
<h2 id="Lab-6-building-an-IP-router"><a href="#Lab-6-building-an-IP-router" class="headerlink" title="Lab 6:  building an IP router"></a>Lab 6:  building an IP router</h2><img src="/2021/07/11/CS144-network-lab/image-20210628230855985.png" alt="image-20210628230855985" style="zoom:80%;">

<p>注意三点:</p>
<ul>
<li>IP地址最长匹配, longest-prefix match.</li>
<li>IP数据报的 TTL.</li>
<li>“direct”: IP数据报的 <code>next hop</code>就是 IP数据报的目标 IP地址.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ysln.github.io/2021/06/28/defer-scope_guard/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yl.chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cyl's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/28/defer-scope_guard/" class="post-title-link" itemprop="url">ScopeGuard & defer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-06-28 00:00:00" itemprop="dateCreated datePublished" datetime="2021-06-28T00:00:00+08:00">2021-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-27 22:15:12" itemprop="dateModified" datetime="2021-07-27T22:15:12+08:00">2021-07-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/modern-C/" itemprop="url" rel="index"><span itemprop="name">modern C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><strong>参考资料</strong>: </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/32432450/what-is-standard-defer-finalizer-implementation-in-c">What is standard defer/finalizer implementation in C++?</a></li>
<li><a target="_blank" rel="noopener" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c30-define-a-destructor-if-a-class-needs-an-explicit-action-at-object-destruction">The C++ Core Guidelines: <code>gsl::finally</code></a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/microsoft/GSL/blob/ebe7ebfd855a95eb93783164ffb342dbd85cbc27/include/gsl/gsl_util#L53-L89">Microsoft的 GSL实现</a></li>
</ul>
</blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>有一个发布 binder service的 server, 和 bind到 server的多个 client. server端有多个 binder线程, 可以<strong>同时</strong>为多个 client执行 RPC. 如果此时 server正在退出(进入析构函数), 而同时还有 client正在执行 RPC, 可能就会出现问题. 虽然可能有其他更合理, 优雅的方式避免这个问题, 但我的直接粗暴的想法是: <strong>当 server退出时, 等待当前正在执行的 RPC完成</strong>. </p>
<p>逻辑大概是这样: server维护一个正在执行 RPC的 client的数量 (<code>std::atomic_int doing_rpc_</code>), 执行 RPC之前该值加一, 执行完成之后减一. 当 server已经进入了析构函数, 等待 <code>doing_rpc_</code>的值变为0(表示没有 client在执行 RPC), 然后才继续析构. 代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> :</span> <span class="keyword">public</span> BnService &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="keyword">atomic_int</span> doing_rpc_ = <span class="number">0</span>;     <span class="comment">// 相当于reference count</span></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> in_dtor_ = <span class="literal">false</span>;  <span class="comment">// 是否进入了析构函数?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Service::~<span class="built_in">Service</span>() &#123;</span><br><span class="line">    in_dtor_.<span class="built_in">store</span>(<span class="literal">true</span>);  <span class="comment">// 声明已经进入析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (doing_rpc_.<span class="built_in">load</span>());   <span class="comment">// wait all RPC done, max 1s</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// clean resource</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::<span class="function">ndk::ScopedAStatus  <span class="title">Service::doRpc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in_dtor_.<span class="built_in">load</span>()) &#123;  <span class="comment">// 如果server正在退出, 则不再执行RPC</span></span><br><span class="line">        <span class="keyword">return</span> ScopedAStatus::<span class="built_in">ok</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++doing_rpc_;  <span class="comment">// 增加 reference count</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">	--doing_rpc_;  <span class="comment">// 减少 reference count</span></span><br><span class="line">    <span class="keyword">return</span> ScopedAStatus::<span class="built_in">ok</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题-amp-分析"><a href="#问题-amp-分析" class="headerlink" title="问题 &amp; 分析"></a>问题 &amp; 分析</h2><p>在 <code>doRpc</code>函数里, 一开始时需要手动增加 <code>doing_rpc_</code>, 在结束时需要手动减少 <code>doing_rpc_</code>. 这就引入了一个问题: 如果在函数里提前退出(发生异常, 或者在中间某个位置提前 <code>return</code>), <code>doing_rpc_</code>的值就永远不会变为0, 析构函数将会陷入死循环 (<em>虽然可以加入最长等待时间限制来避免这个问题</em>).</p>
<p>这其实可以扩展为一个更典型的问题: 即”资源”的获取(acquire)和释放(release). 比如内存的分配与释放(<code>malloc</code>/<code>free</code> 或 <code>new</code>/<code>delete</code>), 锁 (<code>mutex</code>)的加锁与解锁(lock/unlock), 文件 (<code>FILE *</code> 或 <code>fd</code>)或设备(device)的打开与关闭(open/close).</p>
<p>可以发现, 对资源的操作都是成对的(paired). 如果手动管理这种资源, 即手动申请与释放, 是非常容易出错的, 稍不留意就会忘记释放操作, 就像上面的代码那样. 因此, 需要一种方式, 把获取到的资源托管给”它”, 让”它”在合适的位置自动释放资源. </p>
<p>或者更通用一点, 需要一种机制, <strong>可以把某个动作(比如释放资源)推迟到之后的某个时间点执行, 而且需要保证这个动作一定会被执行</strong>. 类似于 <code>scope guard</code>这样的概念.</p>
<p>Java和 Python有 <code>finally</code>语句块, Golang有 <code>defer</code>可以达到上述的功能.</p>
<p>而 C++的解决方法是 <code>RAII(Resource Acquisiton Is Initialization)</code>.  其基本原理是: <strong>C++的类都有构造和析构函数, 在类的生命期一开始, 保证先执行构造函数. 而且在类的生命期结束时, 可以保证它的析构函数被执行. 因此就可以把成对的(paired)操作拆分开来, 一个放到构造函数里面执行, 另一个放到析构函数里面执行</strong>.<code>std::lock_guard</code> 和 <code>std::shared_ptr</code>都是使用 <code>RAII</code>的典范.</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>那么怎样使用 <code>RAII</code>的方式来修改上述代码? </p>
<h3 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a><code>std::shared_ptr</code></h3><p><strong>C++ primer</strong> 第12章讲 <code>shared_ptr</code>时提到, 在创建 <code>shared_ptr</code>时, 可以传递一个自定义的删除器(deleter)给它:</p>
<img src="/2021/06/28/defer-scope_guard/image-20210627112700564.png" alt="image-20210627112700564" style="zoom: 80%;">

<p>需要注意删除器的函数签名需要为 <code>void (T *)</code>, 参数<code>T *</code>就是交给 <code>shared_ptr</code>托管的”资源”(不一定是动态分配的内存, 它可以是广义上的资源).</p>
<p>使用 <code>shared_ptr</code>的方案如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">::<span class="function">ndk::ScopedAStatus  <span class="title">Service::doRpc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in_dtor_.<span class="built_in">load</span>()) &#123;  <span class="comment">// 如果server正在退出, 则不再执行 RPC</span></span><br><span class="line">        <span class="keyword">return</span> ScopedAStatus::<span class="built_in">ok</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++doing_rpc_;  <span class="comment">// 增加 reference count</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="keyword">void</span>&gt; <span class="title">guard</span><span class="params">(<span class="literal">nullptr</span>, [&amp;doing_rpc_] (...) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        --doing_rpc_;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="comment">// 或者</span></span><br><span class="line">    <span class="comment">//std::shared_ptr&lt;std::atomic_int&gt; guard(&amp;doing_rpc_, [](std::atomic_int *rpc) &#123;</span></span><br><span class="line">    <span class="comment">//    --(*rpc);</span></span><br><span class="line">    <span class="comment">//&#125;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">return</span> ScopedAStatus::<span class="built_in">ok</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ScopeGuard"><a href="#ScopeGuard" class="headerlink" title="ScopeGuard"></a><code>ScopeGuard</code></h3><p>借助 <code>RAII</code>思想, 可以实现一个通用的 <code>RAII wrapper class</code>, 比如(下面这种方式有点 naive &amp; trivial):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScopeGuard</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ScopeGuard</span>(T closure) : _closure(std::<span class="built_in">move</span>(closure)) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">ScopeGuard</span>() &#123; _closure(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T _closure;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 我想看一下 C++标准库里有没有类似的实现, 但是很遗憾并没有, 只有这个东西: <code>std::experimental::scope_exit</code>. 虽然它能达到所需的效果, 但是它并不属于标准库的内容. 而且使用 8.4.0 版本的 g++编译会报错.</p>
<p>在 StackOverflow上使用 “C++ scope_guard” 和 “C++ defer”关键字搜索, 也可以找到<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/32432450/what-is-standard-defer-finalizer-implementation-in-c">许多很好的实现</a>.</p>
<h3 id="gsl-finally"><a href="#gsl-finally" class="headerlink" title="gsl::finally"></a><code>gsl::finally</code></h3><p><a target="_blank" rel="noopener" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c30-define-a-destructor-if-a-class-needs-an-explicit-action-at-object-destruction">The C++ Core Guidelines</a> 提出一种方式 <code>gsl::finally</code>:</p>
<img src="/2021/06/28/defer-scope_guard/image-20210627113947634.png" alt="image-20210627113947634" style="zoom:67%;">

<p>下面是其一种<a target="_blank" rel="noopener" href="https://github.com/microsoft/GSL/blob/ebe7ebfd855a95eb93783164ffb342dbd85cbc27/include/gsl/gsl_util#L53-L89">实际的实现</a>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// final_act allows you to ensure something gets run at the end of a scope</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">final_act</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">final_act</span><span class="params">(F f)</span> <span class="keyword">noexcept</span> : f_(std::move(f)), invoke_(true) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">final_act</span>(final_act&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">f_</span>(std::<span class="built_in">move</span>(other.f_)), <span class="built_in">invoke_</span>(other.invoke_)</span><br><span class="line">    &#123;</span><br><span class="line">        other.invoke_ = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">final_act</span>(<span class="keyword">const</span> final_act&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    final_act&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> final_act&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">final_act</span>() <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (invoke_) <span class="built_in">f_</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    F f_;</span><br><span class="line">    <span class="keyword">bool</span> invoke_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// finally() - convenience function to generate a final_act</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> final_act&lt;F&gt; <span class="title">finally</span><span class="params">(<span class="keyword">const</span> F&amp; f)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> final_act&lt;F&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> final_act&lt;F&gt; <span class="title">finally</span><span class="params">(F&amp;&amp; f)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> final_act&lt;F&gt;(std::forward&lt;F&gt;(f));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>gsl::finally</code>的方案如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">::<span class="function">ndk::ScopedAStatus  <span class="title">Service::doRpc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in_dtor_.<span class="built_in">load</span>()) &#123;  <span class="comment">// 如果server正在退出, 则不再执行 RPC</span></span><br><span class="line">        <span class="keyword">return</span> ScopedAStatus::<span class="built_in">ok</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++doing_rpc_;  <span class="comment">// 增加 reference count</span></span><br><span class="line">    <span class="function">gsl::finally <span class="title">guard</span><span class="params">([&amp;doing_rpc_]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        --doing_rpc_;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">return</span> ScopedAStatus::<span class="built_in">ok</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ysln.github.io/2021/05/27/bootloader/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yl.chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cyl's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/27/bootloader/" class="post-title-link" itemprop="url">firmware & bootloader</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-27 00:00:00" itemprop="dateCreated datePublished" datetime="2021-05-27T00:00:00+08:00">2021-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-27 22:16:05" itemprop="dateModified" datetime="2021-07-27T22:16:05+08:00">2021-07-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU-OS-Lab/" itemprop="url" rel="index"><span itemprop="name">NJU OS Lab</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><strong>参考资料</strong>: </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1HN41197Ko?p=4">操作系统也是程序(调试固件和boot loader)</a></li>
</ul>
</blockquote>
<blockquote>
<p>这部分内容 jyy在这门课的开始就讲了, 当时听完之后觉得醍醐灌顶, 但是并没有做笔记. 最近在看rCore时, 发现rCore的内核镜像和启动和这个不太一样. 经过一番痛苦的 RTFSC &amp; RTFM, 发现自己学得还是不太行, 必须得做学习笔记. </p>
</blockquote>
<blockquote>
<p> NJU OS 运行在x86处理器上, 使用C语言编写. 而rCore 运行在 risc-v处理器上, 使用 Rust语言编写.</p>
<p>下面的内容如果没有特别说明, 默认指的是NJU OS和x86处理器.</p>
</blockquote>
<h2 id="固件-Firmware"><a href="#固件-Firmware" class="headerlink" title="固件 (Firmware)"></a>固件 (Firmware)</h2><p>x86手册指定了CPU reset后,  <code>CS:IP</code>指向物理内存的 <strong>0xffff0</strong>处, 这里通常是一条向 firmware跳转的 <code>jmp</code>指令.</p>
<p>firmware, 即固件代码 (BIOS?), 它会把第一个可引导设备的第一个扇区加载到物理内存的 <strong>0x7c00</strong>处. 可以把 firmware理解为第一级boot loader, 它会把第二级boot loader加载到内存中, 然后由第二级boot loader把操作系统内核镜像加载到内存中(或者继续套娃?).</p>
<blockquote>
<p><del>RAM是掉电丢失存储介质, CPU启动后是谁, 怎么把 firmware加载到RAM里</del>. 下面这段话摘自 jyy, 但是不太理解:</p>
<p><em>“x86 CPU reset之后,  PC 指针一般指向一段  <strong>memory-mapped ROM</strong>, ROM存储了厂商提供的 firmware. “</em></p>
<p>“<em>位于 <code>0xffff0</code> 的代码以 <strong>内存映射</strong> 的方式映射到 <strong>只读</strong> 的存储器</em>“.</p>
</blockquote>
<blockquote>
<p>当内核以及加载并启动完成, firmware还存在内存中(?), 也就是 0xffff0往下(其实是0x100000往下)的某段地址范围内, 具体多少不清楚. 当往这段内存写入时, <strong>并不会生效</strong>, 也不会有什么错误发生. 这就可以部分验证 jyy的话, 因为ROM是只读的. 使用下面的代码可以探测出 firmware的范围:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">probe_firmware</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span> *begin;</span><br><span class="line">  <span class="keyword">uint8_t</span> *end;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">uint8_t</span> *bad;  <span class="comment">// 一定得为 volatile</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (bad = (<span class="keyword">uint8_t</span> *)<span class="number">0xfffff</span>; ; ++bad) &#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> old = *bad;</span><br><span class="line">    *bad = <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">if</span> (old != *bad) &#123;</span><br><span class="line">      end = (<span class="keyword">uint8_t</span> *)bad;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (bad = (<span class="keyword">uint8_t</span> *)<span class="number">0xfffff</span>; ; --bad) &#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> old = *bad;</span><br><span class="line">    *bad = <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">if</span> (old != *bad) &#123;</span><br><span class="line">      begin = (<span class="keyword">uint8_t</span> *)bad;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;firmware begin =&gt; 0x%x, end =&gt; 0x%x\n&quot;</span>, begin, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>探测出的 firmware的内存范围为(0xeffff, 0x100000).</p>
<img src="/2021/05/27/bootloader/image-20210523215919418.png" alt="image-20210523215919418" style="zoom: 80%;">
</blockquote>
<h2 id="主引导扇区-MBR"><a href="#主引导扇区-MBR" class="headerlink" title="主引导扇区 (MBR)"></a>主引导扇区 (MBR)</h2><p>前面提到, firmware会把第一个可引导设备的第一个扇区加载到物理内存中. 这个扇区即为主引导扇区, MBR (Master Boot Record). MBR的大小为512字节, 并且其最后两个字节一定得为 <code>0x55aa</code>. 比如, 可以查看电脑磁盘的前512字节:</p>
<img src="/2021/05/27/bootloader/image-20210523221222139.png" alt="image-20210523221222139" style="zoom:67%;">

<p>NJU OS整个项目编译完成之后, 会生成如下的 <strong>磁盘镜像</strong> (下图来自 jyy):</p>
<img src="/2021/05/27/bootloader/image-20210523222311432.png" alt="image-20210523222311432" style="zoom:67%;">

<ul>
<li><p>MBR即为第二级boot loader, 它会把 kernel加载到内存中. </p>
</li>
<li><p><code>mainargs</code> 是传递给内核的参数, 也就是 <code>int main(const char *args)</code>的参数(在kernel/framework/main.c). 在运行时可以这样传递参数:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make smp=4 run mainargs=&quot;hello world 123 789&quot;</span><br></pre></td></tr></table></figure>

<p>它是由以下命令生成的:</p>
<p><img src="/2021/05/27/bootloader/image-20210526224015546.png" alt="image-20210526224015546"></p>
</li>
<li><p>剩余的部分即为内核, 它是 ELF格式的二进制文件.</p>
</li>
</ul>
<p>磁盘镜像是由以下命令生成的 (abstract-machine/scripts/platform/qemu.mk):</p>
<img src="/2021/05/27/bootloader/image-20210526223602682.png" alt="image-20210526223602682" style="zoom:80%;">

<p>MBR不是 ELF格式的文件, 它是一个编译生成的 .o文件经过 objcopy工具生成的二进制文件.</p>
<p><img src="/2021/05/27/bootloader/image-20210523223134628.png" alt="image-20210523223134628"></p>
<p>编译时使用 <code>-Ttext 0x7c00</code>参数指定生成的 .o文件的 .text节的地址为 <code>0x7c00</code>. 并使用下面的 python代码来生成符合要求的MBR:</p>
<img src="/2021/05/27/bootloader/image-20210523224238835.png" alt="image-20210523224238835" style="zoom:67%;">

<blockquote>
<p>不过, 我有一个疑问: 他这里没有使用自定义的链接脚本, 而是使用 gcc默认的链接脚本. 怎么保证 <code>_start</code>函数一定位于 .text的最前面, 也就是 <code>0x7c00</code>处? 还是说这就是 gcc的默认行为?</p>
</blockquote>
<p>这里的MBR的主要作用就是加载内核, 不过在这之前有一堆繁琐诡异的 <del>和硬件相关</del> 和CPU相关的工作要做, 主要是从16位模式切换到32位, <del>64位</del> (<strong>由Abstract Machine完成32位到64位的切换, 这部分代码已经属于”内核”</strong>), 并且设置堆栈指针(<strong>0xa000</strong>), 最后才加载内核. 而加载内核(在这里)<em>看起来</em>是很简单的, 就是解析 ELF文件, 把各个段从磁盘 copy到内存的相应地址范围处, 然后跳转到 <code>entry</code>处执行, 把控制权交给内核.</p>
<h2 id="内核-Kernel"><a href="#内核-Kernel" class="headerlink" title="内核 (Kernel)"></a>内核 (Kernel)</h2><p>这里的内核是一个静态编译链接的 ELF可执行文件, 它包含两个部分:</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://jyywiki.cn/OS/AbstractMachine/">Abstract Machine</a> (<em>仔细阅读 jyy的文档</em>). 它是裸机(Bare-Metal)上的 C 语言运行环境, 提供对底层硬件的抽象(TRM, IOE, CTE, VME, MPE). 可以理解为一种硬件抽象层 (hardware abstraction layer, HAL). Abstract Machine的设计体现了 <strong>机制与策略分离</strong> 的思想.</li>
<li>传统意义上的内核. 提供系统调用, 内存管理, 进程管理, 文件系统等功能. <strong>本质上内核就是一个编译到 Abstract Machine上的 C程序.</strong> </li>
</ul>
<blockquote>
<p>之前的 <strong><a target="_blank" rel="noopener" href="https://nju-projectn.github.io/ics-pa-gitbook/ics2020/">计算机系统基础实验</a></strong> 的侧重点是 <strong>Abstract Machine</strong> 部分. 而这个 OS实验的侧重点是 <strong>内核</strong> 部分.</p>
</blockquote>
<p>链接生成内核 ELF可执行文件的命令如下:</p>
<img src="/2021/05/27/bootloader/image-20210526225320078.png" alt="image-20210526225320078" style="zoom:80%;">

<ul>
<li><code>-N</code>: 标记 <code>.text</code> 和 <code>.data</code> 都可写, 这样它们可以一起加载(即位于同一个段中).</li>
<li><code>-Ttext-segment=0x00100000</code>: 指定二进制文件应加载到地址 <code>0x00100000</code>.</li>
</ul>
<h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><p>Linux x86-64环境下一个典型的C程序进程的内存映像如下图所示:</p>
<img src="/2021/05/27/bootloader/image-20210527203436972.png" alt="image-20210527203436972" style="zoom:80%;">

<p>操作系统内核作为一个 C程序, 其各个段的相对位置也大致一样. 值得注意的是, 每个 C程序编译链接完成后, 默认的链接脚本会导出一个 <code>end</code>符号, 它位于 <code>.bss</code>的结束位置(可能有些对齐要求), 指示了进程的堆区的起始地址.  下图是nemu项目的链接脚本:</p>
<img src="/2021/05/27/bootloader/image-20210527205041849.png" alt="image-20210527205041849" style="zoom:67%;">

<p>NJU OS内核编译完成后也会导出 <code>end</code>符号, <strong><code>end</code>符号之后的地址范围实际上就是操作系统管理的实际物理内存</strong>. 内核创建进程时分配给进程的内存, 以及进程调用 <code>malloc/new</code>分配的内存, 都是从这块物理内存中取得的. 在代码中可以这么使用这个符号:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> end;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;heap start at =&gt; %p\n&quot;</span>, &amp;end);</span><br></pre></td></tr></table></figure>

<p>物理内存 (RAM)是由 qemu模拟/提供的, (类似于 nemu程序中的128MiB的数组). 当 firmware把MBR加载到内存, MBR又把kernel加载到内存之后, 各个部分在物理内存中的分布如下:</p>
<img src="/2021/05/27/bootloader/image-20210527223000279.png" alt="image-20210527223000279" style="zoom:80%;">

<blockquote>
<p>地址 0x7c00以下的物理内存, 有一些 memory-map I/O地址? 以及CPU之间共享的一些内存, 用来保存一些per-CPU的信息. 比如 <code>cpu_id</code>, <code>cpu_count</code>.</p>
</blockquote>
<p>注意, 当每个 CPU跳转到内核执行时(CPU0先进入kernel执行, 它通过 <code>mpe_init</code>函数把其他CPU拉起来), 都会设置各自的栈:</p>
<img src="/2021/05/27/bootloader/image-20210527220509664.png" alt="image-20210527220509664" style="zoom:67%;">

<img src="/2021/05/27/bootloader/image-20210527220550260.png" alt="image-20210527220550260" style="zoom: 80%;">

<img src="/2021/05/27/bootloader/image-20210527220619576.png" alt="image-20210527220619576" style="zoom:67%;">

<img src="/2021/05/27/bootloader/image-20210527220641671.png" alt="image-20210527220641671" style="zoom:67%;">

<p>也就是说, 每个CPU跳转到kernel执行时的初始的栈其实是一个大小为8192 Bytes的全局数组, 这个数组位于内核 ELF文件的 <code>.bss</code>段.</p>
<h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>TODO</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ysln.github.io/2021/05/16/crepl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yl.chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cyl's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/16/crepl/" class="post-title-link" itemprop="url">C语言实现Real-Eval-Print-Loop (REPL)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-16 00:00:00" itemprop="dateCreated datePublished" datetime="2021-05-16T00:00:00+08:00">2021-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-27 22:15:24" itemprop="dateModified" datetime="2021-07-27T22:15:24+08:00">2021-07-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU-OS-Lab/" itemprop="url" rel="index"><span itemprop="name">NJU OS Lab</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><strong>参考资料</strong>: </p>
<ul>
<li><a target="_blank" rel="noopener" href="http://jyywiki.cn/OS/2021/labs/M4">M4: C Real-Eval-Print-Loop (crepl)</a></li>
</ul>
<p>本文是在完成NJU操作系统实验过程中的一些记录.</p>
</blockquote>
<p>很多现代编程语言都提供了交互式的REPL, 比如Python这种”解释执行”的语言. 在REPL中, 除了进行简单的数值计算外(类似计算器), 还可以动态创建函数, 并在之后调用它. </p>
<p>这个实验的目的是使用C语言实现一个简易的REPL. 最终效果如下:</p>
<img src="/2021/05/16/crepl/image-20210501112153656.png" alt="image-20210501112153656" style="zoom: 67%;">

<p><em><strong>这个技术和现代虚拟机中的即时编译 (just-in-time) 技术是非常相关的：在程序运行时 (而非程序执行前) 进行编译，并将编译得到的二进制代码 (指令/数据) 动态加载。</strong></em> — 摘自<a target="_blank" rel="noopener" href="http://jyywiki.cn/OS/2021/labs/M4">jyy的实验指南</a>.</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>C语言是一种编译型的语言, 源文件到二进制文件需要经过编译和链接(link)两个过程. 链接主要完成的工作是<strong>符号解析</strong>和<strong>重定位(<code>relocation</code>)</strong>. </p>
<p>如果是静态链接的程序(<code>-static</code>), 类型为”Executable file(EXEC)”,  即<strong>可执行文件</strong>. 程序中的所有符号都是被完全解析的, 比如所有函数符号的地址都是确定的, 可以直接调用.</p>
<p>GCC默认生成的二进制文件是动态链接的,  生成的文件文件类型为”Shared object file(DYN)”. 一个动态链接的程序从磁盘(disk)上刚加载出来时是 <strong>不完整(部分链接)</strong> 的, 比如程序调用的位于glibc动态链接库中的<code>printf</code>函数地址是未知的. 内核(加载器)不能立即把控制权交给该程序(即跳转到<code>entry</code>). 因此, 需要另外的辅助程序(helper program)的帮助 ——– <strong>dynamic linker</strong>, (一般是ld.so). 它的任务是: <strong>加载程序依赖的DSOs(动态链接库, 比如glibc), 并完成重定位</strong>.</p>
<p>因此, 要想实现一个交互式的REPL, 在程序运行时动态的在其地址空间内加入新的函数符号, 本质上是实现动态链接器的功能.</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>C语言实现的REPL的工作流程如下:</p>
<ol>
<li>读取用户的输入.</li>
<li>把输入的内容写入一个临时的源文件, 并把其编译成一个动态链接库.</li>
<li>把动态链接库加载到进程的地址空间.</li>
<li>计算用户输入的表达式, 输出结果.</li>
<li>重复上述步骤.</li>
</ol>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><img src="/2021/05/16/crepl/image-20210504125129936.png" alt="image-20210504125129936" style="zoom:67%;">

<p>这里有以下注意事项:</p>
<ul>
<li><p>如果用户输入不是函数, 而是表达式, 比如”5 + 6”, 该怎么办? 一个很自然(看完jyy的实验指南后确实很自然…)的想法是把表达式”包装(wrap)”成一个函数, 比如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __wrap_func() &#123; <span class="keyword">return</span> <span class="number">5</span> + <span class="number">6</span>;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这里实现”即时编译”的方法是<code>fork</code>一个子进程, 让子进程执行GCC, 主要是<code>exec</code>函数族(l, v, p, e的组合)的使用, 要注意<code>argv[0]</code>需要为可执行文件的名字.  注意这里把子进程的标准输出和标错误都关闭了, 防止gcc的输出影响.</p>
<p>这里还有一点是如果用户输入”f() + 6”, 那么源文件的内容为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __wrap_func() &#123; <span class="keyword">return</span> f() + <span class="number">6</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>此时gcc编译会给出警告: “f”未定义. 如果”f”在之前定义了, 那么这个警告就无关紧要. 就算”f”没有定义, 也没有关系, 可以把出错处理推迟到加载阶段.</p>
</li>
</ul>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><img src="/2021/05/16/crepl/image-20210501130905417.png" alt="image-20210501130905417" style="zoom:67%;">

<p>可以使用<code>dlopen</code>在运行时加载一个so文件到当前进程的地址空间中. 这里需要注意<code>dlopen</code>的flag参数:</p>
<ul>
<li><p><code>RTLD_GLOBAL</code>是必不可少的, 其含义是: 当前加载的so中的符号对其他so可见, 也就是说之后加载的so符号 <del>解析</del> 绑定(可以理解为符号解析+重定位?)时, 可以使用这个so中的符号. 与其相对的是<code>RTLD_LOCAL</code>. 如果去掉<code>RTLD_GLOBAL</code>, 会出现以下这种情况:</p>
<img src="/2021/05/16/crepl/image-20210501131258559.png" alt="image-20210501131258559" style="zoom:67%;">

<p>注意表达式”f()”也会被”wrap”成一个函数, 并编译成so. </p>
</li>
<li><p><code>RTLD_NOW</code>也是必不可少的, 其含义是: 在加载so时就进行(函数)符号 <del>解析</del> 绑定. 与之相对的是<code>RTLD_LAZY</code>, 表示对应的函数符号 <del>解析</del> 绑定推迟到函数被调用时. </p>
<p>使用<code>RTLD_LAZY</code>参数有以下实验现象:</p>
<img src="/2021/05/16/crepl/image-20210501132200769.png" alt="image-20210501132200769" style="zoom:67%;">

<img src="/2021/05/16/crepl/image-20210504122855560.png" alt="image-20210504122855560" style="zoom:67%;">

<p>也就是说, 定义函数时<strong>可以</strong>使用<strong>当前还未定义</strong>的符号, <code>dlopen</code>时不会报错(因为不会进行符号 <del>解析</del> 绑定). 但是调用时如果找不到对应的函数符号, 进程会直接crash, 结束运行.</p>
<p>而使用<code>RTLD_NOW</code>参数有以下实验现象:</p>
<img src="/2021/05/16/crepl/image-20210501132836648.png" alt="image-20210501132836648" style="zoom:67%;">

<p>也就是说定义函数时<strong>不允许</strong>使用<strong>当前还未定义</strong>的符号, 也不能直接使用未定义的函数计算,  <code>dlopen</code>进行符号 <del>解析</del> 绑定时就会出错. 因此, 这才是我们想要的行为.</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ysln.github.io/2021/05/16/link-load/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yl.chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cyl's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/16/link-load/" class="post-title-link" itemprop="url">链接 & 加载</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-16 00:00:00" itemprop="dateCreated datePublished" datetime="2021-05-16T00:00:00+08:00">2021-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-27 22:14:59" itemprop="dateModified" datetime="2021-07-27T22:14:59+08:00">2021-07-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU-OS-Lab/" itemprop="url" rel="index"><span itemprop="name">NJU OS Lab</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><strong>参考资料</strong>: </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1HN41197Ko?p=19">从零实现动态加载</a></li>
</ul>
</blockquote>
<p>C语言是一种编译型的语言, 源文件到二进制文件需要经过编译和链接(link)两个过程. </p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>这里所说的”编译”指的是由编译器和汇编器生成可重定位目标文件, 即.o文件, 使用<code>file</code>查看一个.o文件会得到如下信息: “ELF 64-bit LSB relocatable”. </p>
<img src="/2021/05/16/link-load/image-20210516150302001.png" alt="image-20210516150302001" style="zoom:67%;">

<p>ELF可重定位目标文件包含了很多个 section, 以及一个供链接器使用的描述各个section信息的节头部表(section header table). </p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接器的输入是一系列可重定位目标文件(包括静态链接库), 它的工作简单来说就是把所有 .o文件的代码( .text等)和数据(.data等)分别整合成 segment(段), 并把它们复制到一个输出文件中, 比如 a.out. 不过在此之前, 链接器需要完成一些额外的工作.</p>
<h3 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h3><p>符号解析即: 把代码中每个引用的符号与它输入的可重定位目标文件的符号表( .symtab)中的一个确定的符号定义关联起来.</p>
<p>如果符号解析失败, 链接器将会报错 <code>undefined reference to xxx</code>. 比如下面的程序:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> y = <span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = func();</span><br><span class="line">    y = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/05/16/link-load/image-20210516153703296.png" alt="image-20210516153703296" style="zoom:67%;">

<p>关于强符号与弱符号及其他详细内容, 参考 <strong>CSAPP</strong> 第7章.</p>
<h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><img src="/2021/05/16/link-load/image-20210516154326502.png" alt="image-20210516154326502" style="zoom:67%;">

<p>比如上面的程序生成的a.o文件中:</p>
<img src="/2021/05/16/link-load/image-20210516155506813.png" alt="image-20210516155506813" style="zoom:67%;">

<p><code>func</code>和<code>x, y</code>这三个符号在运行时刻的地址是未知的(虽然<code>y</code>是定义在本模块的符号), 需要由链接器来确定它们的地址.</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><h3 id="实现一个最简单的”加载器”"><a href="#实现一个最简单的”加载器”" class="headerlink" title="实现一个最简单的”加载器”"></a>实现一个最简单的”加载器”</h3><blockquote>
<p><strong>这里的”加载器”的功能并不是 <code>execve</code>这样的加载器, 而是更像一个玩具版的”动态链接器”?</strong></p>
</blockquote>
<p>程序即<strong>代码加上数据</strong>. Linux下的可执行文件格式是ELF, ELF文件中除了代码和数据外, 还包含了一些辅助信息, 比如供加载器使用的信息. 对于一个最简单的玩具加载器来说, ELF文件中的其他辅助信息都是不必要的, 完全可以把 .o文件中的代码和数据摘取出来, 生成一个二进制文件. 比如下面的程序:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b.c 这个文件里只定义了一个函数<code>func</code>, 它的作用是返回一个数的平方. 使用 gcc的<code>-c</code>选项生成 .o文件(只编译不链接), 然后使用下面的命令生成二进制文件:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objcopy -S -j .text -O binary b.o b.bin</span><br></pre></td></tr></table></figure>

<img src="/2021/05/16/link-load/image-20210516163315766.png" alt="image-20210516163315766" style="zoom:67%;">

<p>生成的 b.bin文件只有16 Bytes. 二进制文件中可以发现一个熟悉的字节<code>c3</code>, 也就是x86指令 <code>retq</code>.</p>
<blockquote>
<p>当前的 b.c中只有代码, 没有数据(即静态变量或全局变量), 因为符号解析和重定位是在链接阶段完成的. 如果要想定义数据, 要么手动完成<del>符号解析</del> 重定位, 要么手写汇编代码, 比如:</p>
<img src="/2021/05/16/link-load/image-20210516173640390.png" alt="image-20210516173640390" style="zoom:67%;">

<p>这里的<code>x</code>这个符号是一个全局/静态数据, 但是它其实是位于代码节.</p>
</blockquote>
<p>可以使用下面的程序来”加载” b.bin:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*FP)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">FP <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd = open(<span class="string">&quot;./b.bin&quot;</span>, O_RDONLY);</span><br><span class="line">  assert(fd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  FP func = mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ | PROT_EXEC, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">  assert(func != (<span class="keyword">void</span> *)<span class="number">-1</span>);</span><br><span class="line">  close(fd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> func;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FP func = load();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">5</span>; ++x) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;x =&gt; %d, func(x) =&gt; %d\n&quot;</span>, x, func(x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的<code>load</code>函数即所谓的”加载器”, 它所做的工作就是打开 b.bin这个文件, 然后使用<code>mmap</code>系统调用, 将当前进程的虚拟地址空间中的一部分映射到打开文件对应的物理页面. 然后把 <code>mmap</code>返回的地址强制转换成函数指针, 这时便可以调用 b.c中的 <code>func</code>函数了.</p>
<p>程序运行结果如下:</p>
<img src="/2021/05/16/link-load/image-20210516170118292.png" alt="image-20210516170118292" style="zoom: 80%;">

<h3 id="真-·-加载器-——-静态链接"><a href="#真-·-加载器-——-静态链接" class="headerlink" title="真 · 加载器 —— 静态链接"></a>真 · 加载器 —— 静态链接</h3><img src="/2021/05/16/link-load/image-20210516174623510.png" alt="image-20210516174623510" style="zoom:67%;">

<p>静态链接生成的ELF文件的类型为”Executable file(EXEC)”. 程序中的所有符号都是被完全解析和重定位的, 比如所有函数符号的地址都是确定的, 在运行时可以直接调用.</p>
<p>ELF可执行文件被设计的很容易加载到内存. 真正的加载器的工作类似于前面那个”玩具加载器”.</p>
<ol>
<li><p>读取ELF头, 根据ELF头找到段头部表(program header table).</p>
</li>
<li><p>根据段头部表的信息, 把需要加载(LOAD)的段(segment)加载到内存中. 例如, 使用<code>mmap</code>系统调用, 把进程的虚拟地址空间中连续的一段内存, 映射到可执行文件中连续的片(chunk), 并赋予这块内存相应的读/写/执行权限.</p>
<img src="/2021/05/16/link-load/image-20210516181932551.png" alt="image-20210516181932551" style="zoom: 67%;"></li>
<li><p>初始化进程的一些运行时环境, 比如栈(<code>argv</code>, <code>envp</code>等). 然后跳转到可执行文件指定的<code>entry</code>执行(通常是<code>_start</code>函数).</p>
<img src="/2021/05/16/link-load/image-20210516180940569.png" alt="image-20210516180940569" style="zoom:67%;"></li>
</ol>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>之前我的认知是动态链接库即 so文件只会在内存中加载一份. 其实更准确来说应该是, <strong>所有文件的只读部分都只会在内存中被加载一份, 所有进程共享.</strong> 只读部分包括 .text和 .rodata等. </p>
<p>比如下面这个程序, 大小约为128MiB, 并且都是位于代码段, 也就是只读的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;.fill 128*1024*1024, 1, 0x90&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;so huge!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) sleep(<span class="number">2</span>);  <span class="comment">// 如果不睡眠, 运行上百个会有点卡</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译出来的 a.out的代码段的大小为 128MiB左右.</p>
<img src="/2021/05/16/link-load/image-20210516190343620.png" alt="image-20210516190343620" style="zoom:67%;">

<p>如果运行100个 a.out程序会怎样? 假如每个进程都要加载一份 a.out的代码和数据到内存中, 可以预料机器将要消耗10GiB内存. 运行之前的内存情况:</p>
<img src="/2021/05/16/link-load/image-20210516190753107.png" alt="image-20210516190753107" style="zoom:67%;">

<p>运行100个 a.out之后:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in $(seq 1 100); do; ./a.out &amp;; done</span><br></pre></td></tr></table></figure>

<img src="/2021/05/16/link-load/image-20210516190923040.png" alt="image-20210516190923040" style="zoom:67%;">

<img src="/2021/05/16/link-load/image-20210516190946974.png" alt="image-20210516190946974" style="zoom:67%;">

<p><strong>那如果是 128MiB可读可写的数据段呢?</strong></p>
<p>考虑下面的程序:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> tab[<span class="number">128LU</span> * <span class="number">1024</span> * <span class="number">1024</span>];  <span class="comment">// 位于 .bss节</span></span><br><span class="line"><span class="comment">// 如果写成 char tab[128LU * 1024 * 1024] = &#123;1&#125;; 则tab位于 .data节</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(tab); i+= <span class="number">4096</span>) &#123;</span><br><span class="line">    tab[i] = <span class="number">7</span>;  <span class="comment">// 如果不这么做, 实际上不会消耗内存</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;so huge!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) sleep(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>程序中定义了一个大小为128MiB的数组<code>tab</code>, 由于没有初始化, 所以它位于 .bss节, 并且编译产生的 a.out大小只有几百KiB, 编译速度也很快. 但是如果 <code>tab</code>初始化了, 则它位于 .data节, 编译产生的 a.out大小约128MiB, 编译速度也很慢, 需要10几秒.</p>
<img src="/2021/05/16/link-load/image-20210516191821201.png" alt="image-20210516191821201" style="zoom:67%;">

<p>运行 a.out之前的内存情况如下, 还有2.8GiB的空闲内存:</p>
<img src="/2021/05/16/link-load/image-20210516192537960.png" alt="image-20210516192537960" style="zoom:67%;">

<p>运行10个 a.out之后, 空闲内存只剩下了1.5GiB, 如果再运行几个, 系统直接卡死:</p>
<img src="/2021/05/16/link-load/image-20210516192719963.png" alt="image-20210516192719963" style="zoom:67%;">

<blockquote>
<p>在上面代码的第7~9行, 每隔4096个字节就写一个数据. 如果删去这几行, 进程实际上不会真正消耗128MiB内存, 即使运行上百个 a.out, 空闲内存也不会减少多少. 这背后的原理(应该?)就是Linux中著名的写时拷贝(Copy on Write, COW). </p>
<p>合理猜测: 加载器在<code>mmap</code>时使用了私有映射标志(<code>MAP_PRIVATE</code>)? 或者说缺页?</p>
</blockquote>
<h3 id="真-·-加载器-——-动态链接"><a href="#真-·-加载器-——-动态链接" class="headerlink" title="真 · 加载器 —— 动态链接"></a>真 · 加载器 —— 动态链接</h3><p>GCC默认生成的二进制文件是动态链接的,  生成的文件文件类型为”Shared object file(DYN)”. 链接器生成动态链接的可执行目标文件时, 并不会 so文件中的代码和 <strong>数据(!!)</strong> 复制到可执行目标文件中. 反之, 链接器只复制了一些重定位和符号表信息, 它们使得运行时可以解析对依赖的 so中的代码和数据的引用.</p>
<p>一个动态链接的程序从磁盘(disk)上刚加载出来时是 <strong>不完整(部分链接)</strong> 的, 比如程序调用的位于glibc动态链接库中的<code>printf</code>函数地址是未知的. 内核(加载器)不能立即把控制权交给该程序(即跳转到<code>entry</code>). 因此, 需要另外的辅助程序(helper program)的帮助 —– <strong>dynamic linker</strong> (一般是ld.so). 它的任务是: <strong>加载程序依赖的DSOs(动态链接库, 比如glibc), 并完成重定位</strong>.</p>
<img src="/2021/05/16/link-load/image-20210516195040666.png" alt="image-20210516195040666" style="zoom:67%;">

<p>动态链接的可执行目标文件的 program header table中专门有一项指定了运行时需要使用的动态链接器, 如下所示:</p>
<img src="/2021/05/16/link-load/image-20210516195417013.png" alt="image-20210516195417013" style="zoom:67%;">

<p>而且动态链接的可执行目标文件的<code>entry</code>也不是<code>_start</code>函数, 而是位于动态链接器中的某个入口函数.</p>
<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><h5 id="GOT-amp-PLT"><a href="#GOT-amp-PLT" class="headerlink" title="GOT &amp; PLT"></a>GOT &amp; PLT</h5><p><strong>PLT位于代码段, GOT位于数据段</strong>. 动态链接器重定位时需要完成的工作就是: 把程序引用的外部符号的地址, 填在对应的GOT表项中. 也就是说需要写GOT, 而GOT位于数据段, 每个进程不共享 so的数据段, 所以并无大碍.</p>
<p>但是如果没有GOT, 那么重定位时就需要直接修改代码段, 把代码中引用的外部符号的地址改成每个进程地址空间中正确的地址(so可能被加载到每个进程虚拟地址空间的不同地方). 也就是说, 需要写代码段, 那这样的话就无法达到共享代码段的目的. 因此, <strong>GOT是必须要的</strong>.</p>
<p><strong>PLT不是必须要的</strong>. 在使用gcc编译时, 可以使用<code>-fno-plt</code>选项, 含义为:</p>
<blockquote>
<p><em>Do not use the PLT for external function calls in position-independent code.  Instead, load the callee address at call sites from the GOT and branch to it.</em></p>
<p>……</p>
<p> <em><strong>Lazy binding requires use of the PLT; with -fno-plt all external symbols are resolved at load time.</strong></em></p>
</blockquote>
<p>使用PLT的一个目的就是<strong>函数符号</strong>延迟绑定. (可以参考<code>dlopen</code>的<code>RTLD_LAZY</code>和<code>RTLD_NOW</code>标志). 但是我实际调试的时候, 好像都是在加载时就完成了符号的绑定, 很奇怪.</p>
<p>关于PLT, GOT, <code>dlopen</code>等详细信息参考 <strong>CSAPP</strong> 第7章.</p>
<h4 id="如果-so中有一个128MiB的全局数组-会发生什么"><a href="#如果-so中有一个128MiB的全局数组-会发生什么" class="headerlink" title="如果 so中有一个128MiB的全局数组, 会发生什么?"></a>如果 so中有一个128MiB的全局数组, 会发生什么?</h4><p>在 ext.c中定义了两个64KiB的数组<code>ext1</code>和<code>ext2</code>, 编译成动态链接库 libext.so. huge.c中引用这两个数组:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ext.c =&gt; gcc -fpic -shared ext.c -o libext.so</span></span><br><span class="line"><span class="keyword">char</span> ext1[<span class="number">64</span>*<span class="number">1024</span>] = &#123;<span class="number">13</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> ext2[<span class="number">64</span>*<span class="number">1024</span>] = &#123;<span class="number">24</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ext1[<span class="number">0</span>]+ext2[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// huge.c =&gt; gcc huge.c -L. -lext</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> ext1[<span class="number">16</span>*<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> ext2[<span class="number">16</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;so huge! ext1[0] = %d, ext2[0] = %d\n&quot;</span>, ext1[<span class="number">0</span>], ext2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  FILE *fp = <span class="built_in">stdin</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;func() =&gt; %d\n&quot;</span>, func());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到编译出来的 libext.so大小为136KiB, 而 a.out的大小为11KiB. 所以可以推断 libext.so中的数据段并没有复制到 a.out中.</p>
<img src="/2021/05/16/link-load/image-20210516202831119.png" alt="image-20210516202831119" style="zoom:80%;">

<p>使用 objdump查看 a.out, 可以发现对 <code>ext1</code>和 <code>ext2</code>这两个外部<strong>变量</strong>符号已经重定位完成, 而 <code>func</code>这个外部<strong>函数</strong>符号还没有重定位.</p>
<img src="/2021/05/16/link-load/image-20210516202629009.png" alt="image-20210516202629009" style="zoom:67%;">

<p>使用 readelf查看 a.out, 可以发现其数据段的大小只有0x270 Bytes, 但是需要加载到地址空间中大小为0x202a8 Bytes, 约为128KiB的一块内存中.</p>
<img src="/2021/05/16/link-load/image-20210516203726500.png" alt="image-20210516203726500" style="zoom:67%;">


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ysln.github.io/2021/05/09/stack-probe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yl.chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cyl's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/09/stack-probe/" class="post-title-link" itemprop="url">动态增长的栈? -- 探索栈的容量</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-09 00:00:00" itemprop="dateCreated datePublished" datetime="2021-05-09T00:00:00+08:00">2021-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-28 20:52:22" itemprop="dateModified" datetime="2021-07-28T20:52:22+08:00">2021-07-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%B0%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">调试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><strong>参考资料</strong>: </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://gcc.gnu.org/wiki/SplitStacks">SplitStacks - GCC Wiki (gnu.org)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/295212303/answer/494630882">程序中的堆和栈大小是动态变化的，还是相对固定的？</a></li>
<li>Go 语言: <a target="_blank" rel="noopener" href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.5.html">3.5 连续栈</a></li>
</ul>
</blockquote>
<blockquote>
<p>首先抛出实验结论(<strong>对于Linux系统, GCC编译器和C 语言</strong>):</p>
<ul>
<li><strong>主线程的栈可以动态增大, 并且增大后不会再减小</strong>.</li>
<li><strong>子线程的栈设定好之后就是固定的, 不会再改变. 默认为8 MiB (由系统控制). 可以使用 <code>pthread_setstacksize</code> 改变默认的栈大小</strong>.</li>
</ul>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Linux系统下, 可以使用 <code>ulimit -a</code> 命令来获取进程运行时的各种资源限制:</p>
<img src="/2021/05/09/stack-probe/image-20210508211457301.png" alt="image-20210508211457301" style="zoom:67%;">

<p>可以看到, 进程的栈的上限为8192 KiB, 即8 MiB. 下面通过实际的程序来验证.</p>
<h2 id="初步验证"><a href="#初步验证" class="headerlink" title="初步验证"></a>初步验证</h2><h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p>使用如下所示的代码来实验, <code>stack_probe</code> 递归调用自身, 每次调用时分配一个大小为1024 Bytes 的数组(还有每次调用函数时的栈帧和其他一些额外的东西), 直到栈溢出:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stack_probe</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmp[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// `n*48` is the frame size(bytes)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sp = %p, size = %4dKib\n&quot;</span>, tmp, n + (n*<span class="number">48</span>)/<span class="number">1024</span>);  </span><br><span class="line"></span><br><span class="line">    stack_probe(n+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stack_probe(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述程序, 栈的深度达到约8 MiB 时, 进程出现段错误而终止:</p>
<img src="/2021/05/09/stack-probe/image-20210508212710613.png" alt="image-20210508212710613" style="zoom:67%;">

<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>修改上述的代码, 创建两个线程, 在线程的回调函数里调用<code>stack_probe</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stack_probe</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmp[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// `n*48` is the frame size(bytes)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%lu] sp = %p, size = %4dKib\n&quot;</span>, pthread_self(), tmp, n + (n*<span class="number">48</span>)/<span class="number">1024</span>);  </span><br><span class="line"></span><br><span class="line">    stack_probe(n+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_func</span><span class="params">(<span class="keyword">void</span> *unused)</span> </span>&#123;</span><br><span class="line">   stack_probe(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">pthread_t</span> tid;</span><br><span class="line">   pthread_create(&amp;tid, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>);</span><br><span class="line">   pthread_create(&amp;tid, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果也一样.</p>
<h2 id="深入验证"><a href="#深入验证" class="headerlink" title="深入验证"></a>深入验证</h2><p>这次我们查看程序运行时的地址空间 —— 通过<code>procfs</code>下面进程 pid 对应的 <code>maps</code> 文件. 要达到这个目的, 需要对程序进行一些修改.</p>
<h3 id="多线程-1"><a href="#多线程-1" class="headerlink" title="多线程"></a>多线程</h3><p>当栈的深度达到约4 MiB 时, 让程序停下来 <code>while (1);</code>:</p>
<blockquote>
<p>至于为什么不用 <code>pause()</code>, 主要是多线程环境再加上信号, 情况有点棘手.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stack_probe</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">4000</span>) <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">char</span> tmp[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// `n*48` is the frame size(bytes)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%lu] sp = %p, size = %4dKib\n&quot;</span>, pthread_self(), tmp, n + (n*<span class="number">48</span>)/<span class="number">1024</span>);  </span><br><span class="line"></span><br><span class="line">    stack_probe(n+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_func</span><span class="params">(<span class="keyword">void</span> *unused)</span> </span>&#123;</span><br><span class="line">   stack_probe(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">pthread_t</span> tid;</span><br><span class="line">   pthread_create(&amp;tid, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>);</span><br><span class="line">   pthread_create(&amp;tid, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当进程停下来时, 查看进程的地址空间:</p>
<p><img src="/2021/05/09/stack-probe/image-20210508215333331.png" alt="image-20210508215333331"></p>
<p>从上图可以看到, 线程1和线程2的栈的容量都正好为8 MiB.</p>
<blockquote>
<p>Thread 1: 0x7f5074544000 - 0x7f5074544000 = 0x800000 = 8 MiB</p>
<p>Thread 2: 0x7f5074d45000 - 0x7f5074545000 = 0x800000 = 8 MiB</p>
</blockquote>
<p><strong>但是, <u>此时(!!!)</u>, 主线程的栈的容量为 132KiB</strong>, 这是一个疑点, 后面会详细讲.</p>
<blockquote>
<p>Main Thread: 0x7f5074d45000 - 0x7f5074545000 = 0x21000 = 132 KiB</p>
</blockquote>
<h3 id="单线程-1"><a href="#单线程-1" class="headerlink" title="单线程"></a>单线程</h3><p>代码修改同上, 也是当栈的深度达到约4 MiB 时, 让程序停下来. 此时进程的地址空间如下:</p>
<p><img src="/2021/05/09/stack-probe/image-20210508220706513.png" alt="image-20210508220706513"></p>
<p>此时, 进程(主线程)的栈的容量为4204 KiB (大约为4 MiB):</p>
<blockquote>
<p>0x7ffe82e4a000 - 0x7ffe82a2f000 = 0x41b000 = 4204 KiB</p>
</blockquote>
<p>但是, 在上一节的实验中, 可以发现<strong>主线程的栈的大小初始为132 KiB, 但是现在栈的大小变为了4 MiB</strong>. 也就是说, <strong>栈的大小动态增长?</strong></p>
<h3 id="动态增长的栈"><a href="#动态增长的栈" class="headerlink" title="动态增长的栈?"></a>动态增长的栈?</h3><p>这次, 修改代码如下, 当栈的深度分别达到64 Kib, 128 KiB, 1 Mib, 4 MiB, 8 Mib 时, 让程序停下来, 查看进程地址空间:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stack_probe</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">63</span>) pause();         <span class="comment">// 64 KiB</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">124</span>) pause();   <span class="comment">// 128 KiB</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">980</span>) pause();   <span class="comment">// 1 MiB</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">3914</span>) pause();  <span class="comment">// 4 MiB</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">7810</span>) pause();  <span class="comment">// 8 MiB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> tmp[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// `n*48` is the frame size(bytes)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%lu] sp = %p, size = %4dKib\n&quot;</span>, pthread_self(), tmp, n + (n*<span class="number">48</span>)/<span class="number">1024</span>);  </span><br><span class="line"></span><br><span class="line">    stack_probe(n+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    signal(SIGINT, sigint_handle);</span><br><span class="line">    </span><br><span class="line">    stack_probe(<span class="number">1</span>);</span><br><span class="line">   	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到以下的结果:</p>
<table>
<thead>
<tr>
<th align="center">探测到的栈的容量</th>
<th align="center">Address Range</th>
<th align="center">Real Stack Size</th>
</tr>
</thead>
<tbody><tr>
<td align="center">64 KiB</td>
<td align="center">0x7ffe7955f000 - 0x7ffe79580000</td>
<td align="center">132 KiB</td>
</tr>
<tr>
<td align="center">128 KiB</td>
<td align="center">0x7ffe7955c000 - 0x7ffe79580000</td>
<td align="center">144 KiB</td>
</tr>
<tr>
<td align="center">1024 KiB</td>
<td align="center">0x7ffe7947c000 - 0x7ffe79580000</td>
<td align="center">1040 KiB</td>
</tr>
<tr>
<td align="center">4096 KiB</td>
<td align="center">0x7ffe7917c000 - 0x7ffe79580000</td>
<td align="center">4112 KiB</td>
</tr>
<tr>
<td align="center">8175Kib (约8 MiB)</td>
<td align="center">0x7ffe78d81000 - 0x7ffe79580000</td>
<td align="center">8188 KiB</td>
</tr>
</tbody></table>
<p>从上表可以看到, 随着 <code>stack_probe</code> 函数的不断递归调用, <strong>栈的实际大小在动态增长</strong>. 并且<strong>栈的地址上界不变, 下界不断减小.</strong></p>
<h3 id="栈增大后能恢复吗"><a href="#栈增大后能恢复吗" class="headerlink" title="栈增大后能恢复吗?"></a>栈增大后能恢复吗?</h3><p>栈的大小确实在运行时增大了, 那么当递归函数返回后, 栈帧销毁时, 栈的大小还会减小为原来的大小吗? 修改代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">7810</span>) pause();  <span class="comment">// 8 MiB</span></span><br><span class="line">+    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">7810</span>) &#123; pause(); <span class="keyword">return</span>;&#125;  <span class="comment">// 8 MiB</span></span><br></pre></td></tr></table></figure>

<p>实验结果是: 并不能! 也就是说, <strong>栈的大小增大后, 不会再减小.</strong></p>
<h2 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h2><p>通过上面的实验, 可以看到<strong>主线程的栈的大小确实可能会在运行时增长</strong>, 直到达到了上限(一般为8MiB). 并且<strong>栈只能增大, 不能减小</strong>.</p>
<p>而<strong>子线程的栈的大小一开始就是确定的, 一般为8MiB, 不会在运行时动态变化</strong>.</p>
<p>下图截取自知乎上的回答: <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/295212303/answer/494630882">程序中的堆和栈大小是动态变化的，还是相对固定的？</a></p>
<img src="/2021/05/09/stack-probe/image-20210508224757890.png" alt="image-20210508224757890" style="zoom:80%;">

<p>此外, gcc 有关于 Split Stacks 的描述: <a target="_blank" rel="noopener" href="https://gcc.gnu.org/wiki/SplitStacks">SplitStacks - GCC Wiki (gnu.org)</a></p>
<blockquote>
<p><em>The goal of split stacks is to permit a discontiguous stack which is grown automatically as needed. This means that you can run multiple threads, each starting with a small stack, and have the stack grow and shrink as required by the program. It is then no longer necessary to think about stack requirements when writing a multi-threaded program. The memory usage of a typical multi-threaded program can decrease significantly, as each thread does not require a worst-case stack size. It becomes possible to run millions of threads (either full NPTL threads or co-routines) in a 32-bit address space.</em></p>
</blockquote>
<p>但是好像并没有达到上面所描述的 “It becomes possible to run millions of threads” , 因为线程的栈的大小是固定不变的(默认为8 MiB).</p>
<p>真正做到上面所描述那样的是 Go 语言, 下面摘自 <a target="_blank" rel="noopener" href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.5.html">3.5 连续栈</a>:</p>
<blockquote>
<p> <em>goroutine可以初始时只给栈分配很小的空间，然后随着使用过程中的需要自动地增长。这就是为什么Go可以开千千万万个goroutine而不会耗尽内存。</em></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ysln.github.io/2021/05/09/threads-on-multi-CPU/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yl.chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cyl's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/09/threads-on-multi-CPU/" class="post-title-link" itemprop="url">硬件线程(hart)&软件线程&CPU</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-09 00:00:00" itemprop="dateCreated datePublished" datetime="2021-05-09T00:00:00+08:00">2021-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-27 22:12:39" itemprop="dateModified" datetime="2021-07-27T22:12:39+08:00">2021-07-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU-OS-Lab/" itemprop="url" rel="index"><span itemprop="name">NJU OS Lab</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><strong>参考资料</strong>:</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://jyywiki.cn/OS/2021/labs/L2">L2: 多处理器内核上的线程管理 (kmt) </a></li>
</ul>
<p>本文是在完成NJU操作系统实验过程中的一些记录.</p>
</blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>“多处理器内核上的线程管理 (kmt)”这个实验并不是很难, 前提是认真听了<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1HN41197Ko?p=10">jyy的课</a>, 以及仔细阅读了jyy的实验指南. 由于没有认真听课, 所以做实验的时候踩了很多坑, 各种各样的并发bug, 虚拟机各种神秘重启.</p>
<p>这个实验和NJU”计算机系统基础”实验<a target="_blank" rel="noopener" href="https://nju-projectn.github.io/ics-pa-gitbook/ics2020/3.2.html">PA3</a>&amp;<a target="_blank" rel="noopener" href="https://nju-projectn.github.io/ics-pa-gitbook/ics2020/4.1.html">PA4</a><del>有点像</del>有点关联, 但两者侧重点不同. </p>
<ul>
<li>PA3&amp;PA4的侧重点是发生中断/异常时<code>context</code>的保存与恢复, 以及怎样创建内核线程(包括context的创建与放置, 如何跳转执行).  而且实验模拟的硬件是单CPU的.</li>
<li>这个实验中context的store/restore已经实现好了, 侧重点是多处理器内核上的线程管理, 关键词: <strong>多CPU</strong>, <strong>线程调度</strong>. </li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="错误的尝试"><a href="#错误的尝试" class="headerlink" title="错误的尝试"></a>错误的尝试</h3><p>一开始, 我的做法是把所有的tasks(相当于线程)组织成一个链表, 用一把大锁(<code>spinlock</code>)保护这个链表. 然后调度发生时, 所有CPU都从这个链表取出可以运行的task执行. 按理来说这是最简单粗暴(但不好)的方法, 应该可以工作. 就像实现内存分配器一样, 先实现用一把大锁保护资源的方案, 然后去掉大锁, 换成CPU-local的方案.</p>
<p>当只创建一些执行简单代码的内核线程时(比如打印字符串), 看起来可以正常工作(好像偶尔还是会panic). 直到实现<code>semaphore</code>, 并创建生产者-消费者线程, 内核开始各种panic, 虚拟机各种神秘重启. 而且大多数情况下都是保护tasks链表的spinlock发生了错误: 同一个CPU重复对该spinlock上锁.</p>
<p>semaphore不同于spinlock, 当一个task获取spinlock失败时会一直”自旋”等待, 并不会让出CPU(<strong>关闭了中断</strong>). 但是当一个task对semaphore执行P操作失败时, 会把当前线程的状态置为SLEEPING, 表示当前task不能被调度执行, 然后执行<code>yield</code>, 主动让出CPU. 直到其他task对该semaphore执行V操作, 唤醒一个等待该semaphore的task. <strong>对semaphore执行V操作可以发生在任意地方, 包括中断处理程序里.</strong></p>
<p>问题就出现在<strong>所有CPU都对同一个tasks链表进行操作</strong>. <em>(我到现在也不知道到底是不是这个问题导致的).</em> 中断发生时(比如时钟中断), 就是线程调度的时刻. 而<strong>每个CPU都是独立响应中断的, 所以线程调度是并发的.</strong></p>
<p>我用尽了各种方法来调试这个问题, 包括gdb, 还是无法找出问题的关键. 当我被折磨得生不如死的时候, 我重新去看了jyy的课, 我确定了新的方案.</p>
<h3 id="有效方案"><a href="#有效方案" class="headerlink" title="有效方案"></a>有效方案</h3><p>把所有的tasks组织成一个链表看起来很简单, 但是<strong>有一个问题: 一个task有可能会被调度到任意一个CPU上去执行</strong>. 为什么不做的更简单彻底一点, 即: <strong>把task绑定到固定的CPU上.</strong></p>
<p>因此新的方案是: tasks链表实现成CPU-local的, 每个CPU只从自己的tasks链表中取出task来执行. 这样在调度发生时, CPU之间不需要争抢同一个spinlock, 效率更高. <em>即使这样, 每个CPU的tasks链表还是分别需要独立的spinlock保护起来</em>. </p>
<blockquote>
<p>关于CPU各自的tasks链表是否需要spinlock保护起来, 需要仔细考虑. 目前的使用场景下, 不需要, 因为在多处理器环境开启之前, 就由CPU0创建好了所有的tasks, 并把tasks分配到每个CPU上. 而且所有的task都不会返回, task不需要回收. 也就是说, 没有链表的插入节点与删除节点的操作.</p>
<p>当然, 使用spinlock也没有问题. 之后拓展使用场景时可能就需要spinlock, 比如: 运行时创建task, 销毁回收task, CPU之间的task迁移(负载均衡?).</p>
</blockquote>
<h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><p>下图截取自jyy的实验指南.</p>
<img src="/2021/05/09/threads-on-multi-CPU/image-20210504203105402.png" alt="image-20210504203105402" style="zoom:67%;">

<p>jyy的代码实现很巧妙, 也很优雅. 但是有一点”误导”了我(我自己的锅, 理解有误). <code>os-&gt;on_irq</code>是用来注册中断处理函数的, 当中断/异常发生时, 便会根据发生的事件, 按序调用注册的handler function. </p>
<p><code>kmt_context_save</code>这个函数的名字让我产生了误解. save的是context这个结构体呢? 还是context指针? 其实这里的语义是<strong>把已经保存在当前task的内核栈上的context的地址/指针, 保存在该task相关的数据结构里面</strong>. 这里<code>kemt_context_save</code>和<code>kmt_schedule</code>分开来了, 并且 <code>kemt_context_save</code>总是<strong>最先</strong>调用, <code>kmt_schedule</code>总是<strong>最后</strong>调用. 之前做”计算机系统基础”实验<a target="_blank" rel="noopener" href="https://nju-projectn.github.io/ics-pa-gitbook/ics2020/3.2.html">PA3</a>时, 我把两部分都放在了调度函数(类似于<code>kmt_schedule</code>)里面. 按照正常的逻辑来说, 两种做法其实是等价的.</p>
<p><strong>那什么是非正常的逻辑? 在handler function(比如时钟/键盘中断处理函数)里面调用<code>yield</code></strong>. 为了方便描述, 假设:</p>
<ol>
<li>方案A: <code>kemt_context_save</code>和<code>kmt_schedule</code>分开, 两者之间可以调用任意的handler function.</li>
<li>方案B: <code>kemt_context_save</code>合并进<code>kmt_schedule</code>里面, 相当于两者是原子的, 所有的handler function调用完毕才会调用<code>kmt_schedule</code>.</li>
</ol>
<p>哪一种方案在这种特殊/非正常情景下有问题? </p>
<p><code>schedule</code>的功能大致如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Context *<span class="title">schedule</span><span class="params">(Event ev, Context *ctx)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 方案B等价于在这里调用yield</span></span><br><span class="line">   </span><br><span class="line">  current_task-&gt;context = ctx;  <span class="comment">// (1) 保存context指针</span></span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 方案A等价于在这里调用yield</span></span><br><span class="line">    </span><br><span class="line">  current_task = select_next_task();  <span class="comment">// (2) 选择一个可运行的task</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> current_task-&gt;context;  <span class="comment">// 之后的代码会把选中的task的context恢复到当前CPU上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方案A等价于在上述代码第6行中调用了<code>yield</code>, 此时又会引发新的一轮context的store/restore: </p>
<img src="/2021/05/09/threads-on-multi-CPU/image-20210504215901784.png" alt="image-20210504215901784" style="zoom: 67%;">

<blockquote>
<p>上图中表示的是被中断/<code>syscall</code>(包括<code>yield</code>)打断时正在运行的task的<strong>内核栈</strong>. 用户进程也需要内核栈, 开启虚拟内存后, 每个用户进程有各自独立的页表, 有不同的虚拟地址空间. 内核栈位于内核的虚拟地址空间之内, 而所有虚拟地址空间都会包含内核映射.</p>
<p> 保存context之前首先需要切换到该task的内核栈, 然后把context保存在内核栈上. 恢复context时, 首先把被选中的task的内核栈上保存的context恢复到CPU上, 最后切换回选中的task的用户栈或内核栈(可能发生中断/异常重入).</p>
<p>需要注意的是: 假设此时task A被中断, 调度程序选中task B来执行. <del>在执行<code>iret</code>(x86)或<code>sret</code>(RISC-V)指令之前</del>, <strong>从上述代码的<code>schedule</code>函数返回前(准确点说应该是<code>__am_irq_handle</code>函数)</strong>, 使用的都是task A的内核栈.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 切换到被中断的task的内核栈, 然后把context保存在内核栈 ...</span><br><span class="line"></span><br><span class="line">mv a0, sp             // 相当于传递给schedule函数的Context *ctx参数</span><br><span class="line">jal __am_irq_handle   // 会调用schedule函数</span><br><span class="line">mv sp, a0             // 切换到选中的task的内核栈</span><br><span class="line"></span><br><span class="line">// 接下来会把栈上保存的context恢复到CPU ...</span><br><span class="line"></span><br><span class="line">lw sp, OFFSET_SP(sp)  // 切换回选中的task的用户栈或内核栈</span><br><span class="line">sret</span><br></pre></td></tr></table></figure>


</blockquote>
<p>当<code>yield</code>返回时(<strong>某次调度发生时, 又选择了该task运行, 此时表明ctx 2已经从该task的内核栈上销毁</strong>), <code>curr-&gt;ctx</code>并没有得到更新: 应该指向ctx 1, 但还是指向<code>yield</code>发生时, 保存到栈上的context(即ctx 2), 但到当前这个时刻ctx 2指向的区域是无效的.</p>
<p>而方案B没有以上问题, 因为传递给<code>schedule</code>函数的<code>ctx</code>参数是保存在该task的内核栈上的(即上图中的stack variable区域, 每个保存在栈上的context后面都会有), 栈上变量在函数的作用域内是有效的, 这是由C语言的机制保证的, <code>ctx</code>参数总是指向最近一次保存在内核栈上的context的地址.</p>
<h2 id="延申思考"><a href="#延申思考" class="headerlink" title="延申思考"></a>延申思考</h2><h3 id="idle-task"><a href="#idle-task" class="headerlink" title="idle task"></a>idle task</h3><p>之前在看Linux内核相关的资料时, 好像在哪看到了idle task这个说法, 一直没有理解这是个啥. 做完这个实验, 我好像有点懂了. <em>以下是个人理解.</em></p>
<p>以前玩单片机时, 程序里先是注册各种中断处理程序, 在最后面总是要加上 <code>while (1);</code>, 然后就开始响应各种中断. 这里的 <code>while (1);</code>其实就可以理解成idle task. CPU总是要干点什么, 即使只是死循环, 不然它就直接shutdown了.</p>
<p>操作系统代码也是一样, 在把所有资源初始化好之后, 它就退变为一个<strong>中断响应程序</strong>. 因此, 它也需要一个idle task, 以防止CPU shutdown. 当没有可运行的task可以调度执行时, 总是需要调度idle task到CPU上执行.</p>
<img src="/2021/05/09/threads-on-multi-CPU/image-20210504154530774.png" alt="image-20210504154530774" style="zoom:67%;">

<h3 id="中断处理函数里不能休眠"><a href="#中断处理函数里不能休眠" class="headerlink" title="中断处理函数里不能休眠?"></a>中断处理函数里不能休眠?</h3><p>之前在看”Linux内核设计与实现”这本书时, 里面提到不能在中断上下文中调用会引起睡眠/阻塞的函数: </p>
<blockquote>
<p><em>中断上下文和进程并没有什么瓜葛. 与current宏也是不相干的(尽管它会指向被中断的进程). 因为没有后备进程, 所以中断上下文不可以睡眠, 否则怎能再对它重新调度呢?</em></p>
</blockquote>
<p>我不太清楚Linux内核关于context的store/restore, 所以对这句话不是很理解.</p>
<p>根据我做完实验的理解, 睡眠即相当于主动调用<code>yield</code>, 让出CPU的执行权. 上文也分析了, 在当前的代码实现中, 在中断处理程序(handler function)里面调用<code>yield</code>, 根据实验现象来看, 无论是单CPU还是多CPU都是没有什么问题的. 还需要仔细思考这个问题.</p>
<h3 id="操作系统是一个并发程序"><a href="#操作系统是一个并发程序" class="headerlink" title="操作系统是一个并发程序"></a>操作系统是一个并发程序</h3><p>jyy在上课时总是在说这句话, 而且在课程安排上, 花了很多时间来讲并发, 和一些看起来和写操作系统代码无关的东西. 做完这个实验, 我又懂了.</p>
<p>当使用比如<code>POSIX threads</code>API创建线程时, 我们知道线程创建之后就会开始并发执行, 并且所有线程共享同一地址空间的全部内容, 比如全局/静态的数据. 每个线程都可以访问并修改全局变量, 并且修改后对其他线程也是可见的. 因此, 我们知道对于对于共享的数据, 需要使用锁保护起来, 比如<code>mutex</code>来提供互斥.</p>
<p>把视角切换回操作系统内核. CPU可以想象成上面提到的”线程”, 而操作系统内核代码可以想象成我们写的多线程程序. 因此, 所有的CPU执行的都是同一份代码, 代码里面所有的全局/静态数据, CPU都可以访问/修改, 并且修改后CPU之间也是可见的. 所以操作系统的代码里同样需要锁来保护共享的数据.</p>
<p>比如xv6的这段代码:</p>
<img src="/2021/05/09/threads-on-multi-CPU/image-20210504161404905.png" alt="image-20210504161404905" style="zoom:67%;">

<p>CPU编号为0的CPU会执行<code>if</code>分支的代码, 其他所有的CPU执行<code>else</code>分支的代码. 由于内核里所有的全局数据都是共享的(比如文件系统相关的资源, 进程表等), 所以只需要由CPU0来初始化一次(当然可以由任意一个CPU来完成这个工作).   如果你足够细心, 你会发现上图中<code>else</code>分支里调用的函数都有<code>hart</code>后缀. 另外, 这里的<code>scheduler</code>也起到了前面提到的idle task的作用.</p>
<h3 id="硬件线程-hart"><a href="#硬件线程-hart" class="headerlink" title="硬件线程(hart)"></a>硬件线程(hart)</h3><p>通过阅读RISC-V的手册, 我得到了以下信息:</p>
<blockquote>
<p><em>hart是硬件线程(hardware thread)的缩略形式. 我们用该术语将它们与大多数程序员熟悉的软件线程区分开来. 软件线程在harts上进行分时复用. 大多数处理器核都只有一个hart.</em></p>
</blockquote>
<p>简单理解, 一个CPU <em>(我不太理解CPU与CPU core的区别, 这里把它们都称作CPU)</em> 就是一个硬件线程(hart), 用户/内核创建的一个软件线程, 对应的就是CPU-local的tasks链表中的一个task.</p>
<p>此外, 我又想到了AMD的<del>县城</del>线程撕裂者:</p>
<img src="/2021/05/09/threads-on-multi-CPU/image-20210504164349104.png" alt="image-20210504164349104" style="zoom:67%;">


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ysln.github.io/2021/05/08/spin-mutex-futex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yl.chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cyl's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/08/spin-mutex-futex/" class="post-title-link" itemprop="url">spinlock & mutex & futex</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-08 00:00:00" itemprop="dateCreated datePublished" datetime="2021-05-08T00:00:00+08:00">2021-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-27 22:14:33" itemprop="dateModified" datetime="2021-07-27T22:14:33+08:00">2021-07-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NJU-OS-Lab/" itemprop="url" rel="index"><span itemprop="name">NJU OS Lab</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%B0%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">调试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><strong>参考资料</strong>: </p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1HN41197Ko?p=10">2021 南京大学 “操作系统：设计与实现” (蒋炎岩)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/3301.html">JEFF DEAN的STANFORD演讲</a></p>
</li>
</ul>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a target="_blank" rel="noopener" href="https://coolshell.cn/articles/3301.html">CoolShell</a> 上看到一篇文章, Jeff Dean 2010年在斯坦福大学的一场题为”Building Software Systems at Google and Lessons Learned”演讲中, 提到的 <em><strong>Numbers Everyone Should Know</strong></em> :</p>
<img src="/2021/05/08/spin-mutex-futex/image-20210403200209265.png" alt="image-20210403200209265" style="zoom: 50%;">

<blockquote>
<p>上图中的数据是2010年左右的, 放到现在来说可能不是太精确(而且对不同硬件配置来说也不一样). 但是这些数据本身也不是为了精确的衡量各种延迟, 主要是看一下数据的数量级, 以及不同项之间的纵向的比率. </p>
<p><a target="_blank" rel="noopener" href="http://norvig.com/21-days.html"><strong>Teach Yourself Programming in Ten Years</strong></a> 这篇文章里也提到了这些数据. </p>
</blockquote>
<p>上图中的数据最令我震惊的是<code>Mutex lock/unlock</code>居然只要<strong>25ns !</strong> </p>
<p>但我在许多地方都看到过这样的言论: <em>“加锁操作的开销是昂贵的, 加锁可能导致性能下降”</em>. 所以我一直以为<code>lock/unlock</code>操作开销至少也得几百微秒, 甚至毫秒级. 但上图颠覆了我的认知, 于是, 亲自做个实验验证一下.</p>
<h2 id="mutex的开销"><a href="#mutex的开销" class="headerlink" title="mutex的开销"></a>mutex的开销</h2><p>测试的代码如下, 只是单纯的在<strong>单线程</strong>程序中进行N次<code>lock/unlock</code>操作, 统计花费的时间:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100000</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start</span>;</span></span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">end</span>;</span></span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> time = (end.tv_sec - <span class="number">1</span> - start.tv_sec) * <span class="number">1000000000</span></span><br><span class="line">                + (end.tv_nsec + <span class="number">1000000000</span> - start.tv_nsec);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Test lock/unlock for [%d] times.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;Total takes [%ld] ns.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;One cycle takes [%ld] ns.\n&quot;</span>, N, time, time / N);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用gcc编译(不优化), 测试的机器的处理器为 “<strong>Intel(R) Core(TM) i5-6300HQ CPU @ 2.30GHz   2.30 GHz</strong>“, 系统为<code>VirtualBox</code>虚拟机上运行的<code>Ubuntu 18.04</code>, 虚拟机配置为两个CPU.</p>
<p>程序的运行结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test lock/unlock for [100000] times.</span><br><span class="line">Total takes [3223049] ns.</span><br><span class="line">One cycle takes [32] ns.</span><br></pre></td></tr></table></figure>

<p>结果和Jeff Dean提到的数据确实也<strong>基本吻合</strong>, <strong>几十纳秒的数量级</strong>! </p>
<h2 id="fast-path-amp-slow-path"><a href="#fast-path-amp-slow-path" class="headerlink" title="fast path &amp; slow path"></a>fast path &amp; slow path</h2><p>按理来说, 实验到这里也就结束了, 但是之后在看jyy老师的OS课程时, jyy提到操作系统的两种锁实现: <code>spinlock</code>和<code>mutexlock</code>(姑且叫这个名字).</p>
<p><code>spinlock</code>只要使用一条原子指令就可以完成, x86平台下提供的<code>lock</code>前缀的指令就可以达到这个目的, 比如<code>lock xchg</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equal to ==&gt; swap(*addr, newval)</span></span><br><span class="line"><span class="function"><span class="keyword">intptr_t</span> <span class="title">atomic_xchg</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">intptr_t</span> *addr, <span class="keyword">intptr_t</span> newval)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">intptr_t</span> result;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;lock xchg %0, %1&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">                  : <span class="string">&quot;+m&quot;</span>(*addr), <span class="string">&quot;=a&quot;</span>(result)</span></span></span><br><span class="line"><span class="params"><span class="function">                  : <span class="string">&quot;1&quot;</span>(newval)</span></span></span><br><span class="line"><span class="params"><span class="function">                  : <span class="string">&quot;cc&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (atomic_xchg(&amp;lock-&gt;locked, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// wait</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// wake</span></span><br><span class="line">    atomic_xchg(&amp;locked-&gt;locked, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此, <code>spinlock</code>不需要经过系统调用就可以实现线程间的互斥访问共享资源, 众所周知系统调用的开销相对来说是很大的(一般为<strong>微秒级</strong>).</p>
<p>但是, 在<code>spinlock</code>上的等待的线程不断地执行<code>lock xchg</code>, 白白浪费宝贵的处理器时间.</p>
<p>一种合理的改进方法是, 当线程获取锁失败时, 不是让它满等待, 而是让操作系统把线程的执行状态改成某个标识, 比如<code>blocking in a lock</code>, 下次操作系统调度线程执行时就不再调度它执行, 直到等待的锁被释放, 才把该线程的状态改成<code>runnable</code>. 姑且把这种锁机制称为<code>mutexlock</code>.</p>
<p>从上述的描述中可以发现, <code>mutexlock</code>需要操作系统的支持, 也就是说操作系统需要提供一个类似<code>SYS_lock</code>的系统调用接口, 而系统调用的开销较大, 如果<code>POSIX mutex</code>使用这种实现, 我相信<code>lock/unlock</code>的时间肯定不止几十纳秒.</p>
<p><code>spinlock</code>和<code>mutexlock</code>各有其优劣, 那么能不能结合两种锁各自的优点, 设计一种新的锁机制?</p>
<p>当然可以! 这背后的思想便是jyy多次提到的 <strong>fast path &amp; slow path</strong> (jyy在讲内存分配的设计时也提到了这种思想).</p>
<ul>
<li>fast path: 只需要一条原子指令(比如<code>lock xchg</code>), 上锁成功立即返回.</li>
<li>slow path: 上锁失败, 调用系统调用, 让操作系统调度其他线程执行(相当于进入睡眠).</li>
</ul>
<p>这便是 <strong>Futex(Fast Userspace muTexes)</strong> 的设计思想. 但是使用上面这种方式, <code>unlock</code>时至少也需要一次系统调用, 用来”唤醒”在该锁上<code>blocking</code>的线程, 而如果此时没有其他线程在等待这把锁, 此次系统调用就是多余的. 然而实际使用的<code>Futex</code>的实现中不会有这个问题, 它使用了一些巧妙的设计避免了<code>unlock</code>时不必要的系统调用.</p>
<h2 id="深入验证"><a href="#深入验证" class="headerlink" title="深入验证"></a>深入验证</h2><p><code>futex</code>是Linux系统提供的系统调用, <code>POSIX mutex</code>就是用<code>futex</code>机制实现的.</p>
<img src="/2021/05/08/spin-mutex-futex/image-20210403213833104.png" alt="image-20210403213833104" style="zoom: 80%;">

<p>下面深入验证一下上文的验证程序是否调用了该系统调用.</p>
<h3 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h3><p>使用<code>strace</code>来跟踪程序使用的系统调用, 过滤一些输出:</p>
<img src="/2021/05/08/spin-mutex-futex/image-20210403214635686.png" alt="image-20210403214635686" style="zoom:80%;">

<p>可以看到没有调用<code>futex</code>. 会不会是被编译器优化了?</p>
<p>使用<code>objdump</code>看一下编译生成的 a.out:</p>
<img src="/2021/05/08/spin-mutex-futex/image-20210403214955744.png" alt="image-20210403214955744" style="zoom:80%;">

<p>可以看到确实有调用<code>pthread_mutex_lock/pthread_mutex_unlock</code>.</p>
<p>那么看一下一个典型的多线程程序(多个线程并发对全局变量执行自增操作, 用<code>mutex</code>保护该全局变量)的结果:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;threads.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000000</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sum</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        sum++;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        create(do_sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    join_all();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %ld\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了jyy提供的”threads.h”, 其实就是封装了一下<code>pthread</code>库, 用起来更简单些. <code>strace</code>的结果如下(<strong>注意需要使用<code>-f</code>选项</strong>):</p>
<img src="/2021/05/08/spin-mutex-futex/image-20210403220412333.png" alt="image-20210403220412333" style="zoom:80%;">

<p>可以看到确实调用了<code>futex</code>, 并且每次调用的平均耗时为几十微秒:</p>
<img src="/2021/05/08/spin-mutex-futex/image-20210505093231322.png" alt="image-20210505093231322" style="zoom:67%;">

<h3 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h3><h4 id="原始测试程序-单线程"><a href="#原始测试程序-单线程" class="headerlink" title="原始测试程序(单线程)"></a>原始测试程序(单线程)</h4><p>接下来使用gdb来调试一下原始那个测试程序. <strong>注意这个程序是单线程程序</strong>.</p>
<ol>
<li><p>单步调试进入<code>pthread_mutex_lock</code>函数. </p>
<img src="/2021/05/08/spin-mutex-futex/image-20210403221601612.png" alt="image-20210403221601612" style="zoom: 67%;">

<p><code>lock cmpxchg</code>便是<code>spinlock</code>中提到的原子交换指令. </p>
</li>
<li><p>单步运行<code>si</code>:</p>
<img src="/2021/05/08/spin-mutex-futex/image-20210403221959408.png" alt="image-20210403221959408" style="zoom:67%;">

<p>执行原子交换指令后, 下一条<code>je</code>指令判断成功, 跳转到目标处执行, 然后函数返回<code>retq</code>. 这种情况对于的是<code>pthread_mutex_lock</code>函数获取锁成功, 立即返回, <strong>可以看到没有执行任何系统调用</strong>(<code>syscall</code>).</p>
<p><strong>那如果获取失败呢?</strong> 可以从上图中看到<code>je</code>后面的第3条指令调用了<code>__lll_lock_wait</code>函数, 这个先不管它, 之后会调试.</p>
</li>
<li><p>单步调试进入<code>pthread_mutex_unlock</code>函数:</p>
<img src="/2021/05/08/spin-mutex-futex/image-20210403222933633.png" alt="image-20210403222933633" style="zoom:67%;">

<p>可以看到这里的原子指令是 <strong><code>lock decl</code></strong>(相当于原子的自减操作), 而不是<code>lock cmpxchg</code>.</p>
</li>
<li><p>单步运行<code>si</code>:</p>
<img src="/2021/05/08/spin-mutex-futex/image-20210403223247470.png" alt="image-20210403223247470" style="zoom:67%;">

<p>执行原子交换指令后, 下一条<code>je</code>指令判断成功, 跳转到目标处执行, 然后函数返回<code>retq</code>. 这种情况对于的是<code>pthread_mutex_unlock</code>函数解锁, 并且<strong>没有其他线程在等待这把锁</strong>, 立即返回, <strong>可以看到没有执行任何系统调用</strong>(<code>syscall</code>).</p>
<p><strong>如果<code>je</code>判断失败呢?</strong> 这对应的其实是释放锁时, <strong>有其他线程在等待这把锁</strong>, 所以要调用<code>__lll_unlock_wake</code>函数, 这里先不管它, 之后会调试.</p>
</li>
</ol>
<h4 id="典型多线程程序"><a href="#典型多线程程序" class="headerlink" title="典型多线程程序"></a>典型多线程程序</h4><p>现在调试一下典型多线程程序(即上面第2个程序). 为了方便调试, 只创建2个子线程(包括主线程, 总共有3个线程).</p>
<ol>
<li><p>在<code>do_sum</code>函数打断点, 运行, 然后<code>set scheduler-locking on</code>, 这个命令的作用是: 调试当前线程时, 让其他线程处于停止的状态.</p>
<img src="/2021/05/08/spin-mutex-futex/image-20210403224303366.png" alt="image-20210403224303366" style="zoom:67%;"></li>
<li><p>当前是 thread 2在运行, <code>LWP 26992</code>是该线程的ID, 之后会用到该ID. 先调试该线程. </p>
<p>进入<code>pthread_mutex_unlock</code>函数, 可以预料到它可以成功执行<code>pthread_mutex_lock</code>, 获取到全局变量<code>mutex</code>的所有权, 结果也确实如此:</p>
<p><img src="/2021/05/08/spin-mutex-futex/image-20210403224921759.png" alt="image-20210403224921759"></p>
<p><code>mutex</code>的<code>Owner ID</code>确实是 thread 2的ID, <code>mutex</code>的状态是**<code>Acquired, possibly with no waiters</code>**, 表示已经被上锁, 并且没有其他线程在等待该锁.</p>
</li>
<li><p>现在切换到 thread 3运行. 进入<code>pthread_mutex_lock</code>函数, 由于全局的锁<code>mutex</code>已经被 thread 2获取了, 可以预料到 <em><del>该函数调用将会失败</del></em> 原子交换指令将会发现”失败”:</p>
<img src="/2021/05/08/spin-mutex-futex/image-20210403225402579.png" alt="image-20210403225402579" style="zoom:67%;">

<p>结果确实如此, <code>je</code>判断失败, 然后调用<code>__lll_lock_wait</code>函数.</p>
</li>
<li><p>进入<code>__lll_lock_wait</code>函数:</p>
<img src="/2021/05/08/spin-mutex-futex/image-20210403225715719.png" alt="image-20210403225715719" style="zoom:67%;">

<p>可以看到确实执行了<code>syscall</code>指令, <code>0xca/202</code>是系统调用编号:</p>
<p><img src="/2021/05/08/spin-mutex-futex/image-20210403230018553.png" alt="image-20210403230018553"></p>
<p>确实是 <strong><code>futex</code></strong>! </p>
</li>
<li><p>这时 thread 3阻塞在获取<code>mutex</code>, 相当于进入了”睡眠”. </p>
<p>切换回 thread 2执行:</p>
<img src="/2021/05/08/spin-mutex-futex/image-20210403230903882.png" alt="image-20210403230903882" style="zoom:80%;">

<p>此时<code>mutex</code>的状态是 <strong><code>Acquired, possibly with waiters</code></strong>, 表示有其他线程在等待获取该锁. </p>
</li>
<li><p>进入<code>pthread_mutex_lock</code>函数, 由于 thread 3此时正在等待这把锁, 可以预料到<code>lock decl</code>之后的判断将会失败:</p>
<img src="/2021/05/08/spin-mutex-futex/image-20210403231509194.png" alt="image-20210403231509194" style="zoom:67%;">

<p>可以看到确实是这样.</p>
</li>
<li><p>进入<code>__lll_unlock_wake</code>函数:</p>
<img src="/2021/05/08/spin-mutex-futex/image-20210403231651108.png" alt="image-20210403231651108" style="zoom:67%;">

<p>可以看到确实调用了<code>0xca</code>号系统调用, 即 <strong><code>futex</code></strong>!</p>
</li>
<li><p>切换回 thread 3, 由于 thread 2释放了<code>mutex</code>, 可以预料到 thread 3从<code>syscall</code>返回后会成功获取到<code>mutex</code>的所有权:</p>
<img src="/2021/05/08/spin-mutex-futex/image-20210403232133401.png" alt="image-20210403232133401" style="zoom: 80%;">

<p><code>mutex</code>的<code>Owner ID</code>确实是 thread 3. 不过<code>mutex</code>的<code>status</code>有点诡异, 因为按理来说此时应该没有其他线程在等待该锁.</p>
</li>
</ol>
<h2 id="Futex"><a href="#Futex" class="headerlink" title="Futex"></a>Futex</h2><p>自行查阅<code>Linux man pages</code>: <strong><code>man futex</code></strong>.</p>
<h2 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h2><p>在最近的工作中, 使用了<code>libusb</code>库. 程序使用的是库推荐的<code>Asynchronous I/O</code>, 代码模式使用的也是文档的示例模式: 创建一个单独的线程, 不停的调用<code>libusb_handle_events</code>处理异步的事件. </p>
<p>查阅文档, 看到<code>libusb_handle_events</code>可以在多个线程中安全的使用, 因为它内部有一个<code>event_lock</code>. 但是我使用的程序中只用了一个线程调用<code>libusb_handle_events</code>来处理异步事件, 于是换成<code>libusb_handle_events_locked</code>接口, 省去额外的<code>lock/unlock</code>. 但是, 实际结果, 两种方式差别不大. 通过上文的分析, 该结果也不难理解.</p>
<p><del>此外, 在看<code>c++</code>的<code>std::shared_ptr</code>时, 我看到有的地方说<code>shared_ptr</code>内部的引用计数为了<code>thread-safety</code>, 有相应的锁保护, 如果过度使用它, 可能会有性能问题. 真的是这样吗? 有多大的性能下降?</del></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ysln.github.io/2021/05/05/open-args/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yl.chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cyl's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/05/open-args/" class="post-title-link" itemprop="url">open函数有2个参数还是3个参数?</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-05 00:00:00" itemprop="dateCreated datePublished" datetime="2021-05-05T00:00:00+08:00">2021-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-27 22:14:48" itemprop="dateModified" datetime="2021-07-27T22:14:48+08:00">2021-07-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/trick/" itemprop="url" rel="index"><span itemprop="name">trick</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><strong>参考资料</strong>:</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://locklessinc.com/articles/overloading/">Overloading Functions in C</a></li>
<li><a target="_blank" rel="noopener" href="https://bbs.csdn.net/topics/390901940">linux c程序调用open函数为什么两个或三个参数都可以？</a></li>
</ul>
</blockquote>
<p>以前在使用<code>open</code>这个函数的时候, 隐隐记得2个参数和3个参数的版本都使用过, 当时没怎么当回事, 本文主要看看这背后有哪些tricks.</p>
<h2 id="tricky"><a href="#tricky" class="headerlink" title="tricky?"></a>tricky?</h2><p>查看<code>open</code>的man手册:</p>
<img src="/2021/05/05/open-args/image-20210505121956142.png" alt="image-20210505121956142" style="zoom:67%;">

<p>可以看到<code>open</code>函数确实存在”两个版本”, 第3个参数表示创建文件时指定的mode(r/w/x), 手册里是这么说的: <em>This argument must be supplied when O_CREAT or O_TMPFILE is specified in flags; if neither O_CREAT nor O_TMPFILE is specified, then mode is ignored.</em></p>
<p>根据我的经验, C语言是不支持函数重载的, 定义两个全局的同名函数编译/链接会出错(<em>这里和强/弱符号的概念不是同一个层次上的问题</em>). 但是C语言支持可变参数函数 (variadic function), 比如<code>printf</code>.</p>
<p>使用可变参数函数需要显式或者隐式的告诉被调用的函数当前传递了几个参数给它, 比如下面这种显示的做法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_variadic</span><span class="params">(<span class="keyword">int</span> count, ...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (count) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个函数通过<code>count</code>这个参数可以知道后面还有几个参数, 然后便可以根据参数个数做相应的动作, 比如调用对应参数个数的其他函数.</p>
<p>但这种显示指定参数个数很不方便, 像<code>printf</code>函数就是隐式指定参数个数, 其签名大概如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%s] has %d args.&quot;</span>, <span class="string">&quot;printf&quot;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><code>fmt</code>参数是要输出的格式化字符串, <code>%s</code>和<code>%d</code>相当于占位符(placeholder), 每个占位符表示后面还有一个对应的参数, 因此<code>printf</code>可以正确的处理任意个数的参数.</p>
<p><code>open</code>函数也可以使用类似的方法实现. 再来看一下它的签名:</p>
<img src="/2021/05/05/open-args/image-20210505121956142.png" alt="image-20210505121956142" style="zoom:67%;">

<p>第3个参数<code>mode</code>只有在<code>flags</code>包含<code>O_CREAT </code>或 <code>O_TMPFILE</code>时才会用到. 因此可以根据<code>open</code>函数可以根据<code>flags</code>来确定当前的调用是有2个参数还是3个参数.</p>
<p>上面这些都只是C语言可变参数函数的正常用法, 算不上tricky.</p>
<h2 id="tricky-1"><a href="#tricky-1" class="headerlink" title="tricky!"></a>tricky!</h2><p><a target="_blank" rel="noopener" href="http://locklessinc.com/articles/overloading/">Overloading Functions in C</a> 这篇文章里提到了如何在C语言中实现函数重载, 包括参数个数和参数类型的重载, 而且还可以实现默认参数, 很有意思.</p>
<p>这里的<code>open</code>函数其实是参数个数的重载, 使用下面这个宏就可以得到参数的个数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COUNT_PARMS2(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, n, ...) n</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COUNT_PARMS(...) \</span></span><br><span class="line"><span class="meta">	COUNT_PARMS2(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)</span></span><br></pre></td></tr></table></figure>

<p>然后<code>open</code>可以实现成这样(虽然没什么用):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open3</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flag, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CONCAT(x, y)  x ## y</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  CONCAT(x, y)  _CONCAT(x, y)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> open(...) \</span></span><br><span class="line"><span class="meta">	CONCAT(open, COUNT_PARMS(__VA_ARGS__))(__VA_ARGS__)</span></span><br></pre></td></tr></table></figure>

<p>之前学Rust时偶然看到<code>select!</code>的实现也是很魔幻的写法, 类似于<code>COUNT_PARMS</code>, 当时没有仔细看, 现在看<code>select!</code>的实现好像和之前看到的不一样了.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yl.chen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/YsLn" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;YsLn" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yl.chen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
