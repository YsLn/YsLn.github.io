<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cyl&#39;s blog</title>
  
  
  <link href="https://ysln.github.io/atom.xml" rel="self"/>
  
  <link href="https://ysln.github.io/"/>
  <updated>2021-05-04T14:36:48.685Z</updated>
  <id>https://ysln.github.io/</id>
  
  <author>
    <name>yl.chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>硬件线程(hart)&amp;软件线程&amp;CPU</title>
    <link href="https://ysln.github.io/2021/05/04/threads-on-multi-CPU/"/>
    <id>https://ysln.github.io/2021/05/04/threads-on-multi-CPU/</id>
    <published>2021-05-04T04:58:49.186Z</published>
    <updated>2021-05-04T14:36:48.685Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em><strong>参考资料: <a href="http://jyywiki.cn/OS/2021/labs/L2">L2: 多处理器内核上的线程管理 (kmt) </a></strong></em></p><p>本文是在完成NJU操作系统实验过程中的一些记录.</p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>“多处理器内核上的线程管理 (kmt)”这个实验并不是很难, 前提是认真听了<a href="https://www.bilibili.com/video/BV1HN41197Ko?p=10">jyy的课</a>, 以及仔细阅读了jyy的实验指南. 由于没有认真听课, 所以做实验的时候踩了很多坑, 各种各样的并发bug, 虚拟机各种神秘重启.</p><p>这个实验和NJU”计算机系统基础”实验<a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2020/3.2.html">PA3</a>&amp;<a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2020/4.1.html">PA4</a><del>有点像</del>有点关联, 但两者侧重点不同. </p><ul><li>PA3&amp;PA4的侧重点是发生中断/异常时<code>context</code>的保存与恢复, 以及怎样创建内核线程(包括context的创建与放置, 如何跳转执行).  而且实验模拟的硬件是单CPU的.</li><li>这个实验中context的store/restore已经实现好了, 侧重点是多处理器内核上的线程管理, 关键词: <strong>多CPU</strong>, <strong>线程调度</strong>. </li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="错误的尝试"><a href="#错误的尝试" class="headerlink" title="错误的尝试"></a>错误的尝试</h3><p>一开始, 我的做法是把所有的tasks(相当于线程)组织成一个链表, 用一把大锁(<code>spinlock</code>)保护这个链表. 然后调度发生时, 所有CPU都从这个链表取出可以运行的task执行. 按理来说这是最简单粗暴(但不好)的方法, 应该可以工作. 就像实现内存分配器一样, 先实现用一把大锁保护资源的方案, 然后去掉大锁, 换成CPU-local的方案.</p><p>当只创建一些执行简单代码的内核线程时(比如打印字符串), 看起来可以正常工作(好像偶尔还是会panic). 直到实现<code>semaphore</code>, 并创建生产者-消费者线程, 内核开始各种panic, 虚拟机各种神秘重启. 而且大多数情况下都是保护tasks链表的spinlock发生了错误: 同一个CPU重复对该spinlock上锁.</p><p>semaphore不同于spinlock, 当一个task获取spinlock失败时会一直”自旋”等待, 并不会让出CPU(<strong>关闭了中断</strong>). 但是当一个task对semaphore执行P操作失败时, 会把当前线程的状态置为SLEEPING, 表示当前task不能被调度执行, 然后执行<code>yield</code>, 主动让出CPU. 直到其他task对该semaphore执行V操作, 唤醒一个等待该semaphore的task. <strong>对semaphore执行V操作可以发生在任意地方, 包括中断处理程序里.</strong></p><p>问题就出现在<strong>所有CPU都对同一个tasks链表进行操作</strong>. <em>(我到现在也不知道到底是不是这个问题导致的).</em> 中断发生时(比如时钟中断), 就是线程调度的时刻. 而<strong>每个CPU都是独立响应中断的, 所以线程调度是并发的.</strong></p><p>我用尽了各种方法来调试这个问题, 包括gdb, 还是无法找出问题的关键. 当我被折磨得生不如死的时候, 我重新去看了jyy的课, 我确定了新的方案.</p><h3 id="有效方案"><a href="#有效方案" class="headerlink" title="有效方案"></a>有效方案</h3><p>把所有的tasks组织成一个链表看起来很简单, 但是<strong>有一个问题: 一个task有可能会被调度到任意一个CPU上去执行</strong>. 为什么不做的更简单彻底一点, 即: <strong>把task绑定到固定的CPU上.</strong></p><p>因此新的方案是: tasks链表实现成CPU-local的, 每个CPU只从自己的tasks链表中取出task来执行. 这样在调度发生时, CPU之间不需要争抢同一个spinlock, 效率更高. <em>即使这样, 每个CPU的tasks链表还是分别需要独立的spinlock保护起来</em>. </p><blockquote><p>关于CPU各自的tasks链表是否需要spinlock保护起来, 需要仔细考虑. 目前的使用场景下, 不需要, 因为在多处理器环境开启之前, 就由CPU0创建好了所有的tasks, 并把tasks分配到每个CPU上. 而且所有的task都不会返回, task不需要回收. 也就是说, 没有链表的插入节点与删除节点的操作.</p><p>当然, 使用spinlock也没有问题. 之后拓展使用场景时可能就需要spinlock, 比如: 运行时创建task, 销毁回收task, CPU之间的task迁移(负载均衡?).</p></blockquote><h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><p>下图截取自jyy的实验指南.</p><img src="/2021/05/04/threads-on-multi-CPU/image-20210504203105402.png" alt="image-20210504203105402" style="zoom:67%;"><p>jyy的代码实现很巧妙, 也很优雅. 但是有一点”误导”了我(我自己的锅, 理解有误). <code>os-&gt;on_irq</code>是用来注册中断处理函数的, 当中断/异常发生时, 便会根据发生的事件, 按序调用注册的handler function. </p><p><code>kmt_context_save</code>这个函数的名字让我产生了误解. save的是context这个结构体呢? 还是context指针? 其实这里的语义是<strong>把已经保存在当前task的内核栈上的context的地址/指针, 保存在该task相关的数据结构里面</strong>. 这里<code>kemt_context_save</code>和<code>kmt_schedule</code>分开来了, 并且 <code>kemt_context_save</code>总是<strong>最先</strong>调用, <code>kmt_schedule</code>总是<strong>最后</strong>调用. 之前做”计算机系统基础”实验<a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2020/3.2.html">PA3</a>时, 我把两部分都放在了调度函数(类似于<code>kmt_schedule</code>)里面. 按照正常的逻辑来说, 两种做法其实是等价的.</p><p><strong>那什么是非正常的逻辑? 在handler function(比如时钟/键盘中断处理函数)里面调用<code>yield</code></strong>. 为了方便描述, 假设:</p><ol><li>方案A: <code>kemt_context_save</code>和<code>kmt_schedule</code>分开, 两者之间可以调用任意的handler function.</li><li>方案B: <code>kemt_context_save</code>合并进<code>kmt_schedule</code>里面, 相当于两者是原子的, 所有的handler function调用完毕才会调用<code>kmt_schedule</code>.</li></ol><p>哪一种方案在这种特殊/非正常情景下有问题? </p><p><code>schedule</code>的功能大致如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Context *<span class="title">schedule</span><span class="params">(Event ev, Context *ctx)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 方案B等价于在这里调用yield</span></span><br><span class="line">   </span><br><span class="line">  current_task-&gt;context = ctx;  <span class="comment">// (1) 保存context指针</span></span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 方案A等价于在这里调用yield</span></span><br><span class="line">    </span><br><span class="line">  current_task = select_next_task();  <span class="comment">// (2) 选择一个可运行的task</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> current_task-&gt;context;  <span class="comment">// 之后的代码会把选中的task的context恢复到当前CPU上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案A等价于在上述代码第6行中调用了<code>yield</code>, 此时又会引发新的一轮context的store/restore: </p><img src="/2021/05/04/threads-on-multi-CPU/image-20210504215901784.png" alt="image-20210504215901784" style="zoom: 67%;"><p>当<code>yield</code>返回时(<strong>某次调度发生时, 选择了该task运行, 此时表明ctx 2已经从该task的内核栈上销毁</strong>), <code>curr-&gt;ctx</code>并没有得到更新: 应该指向ctx 1, 但还是指向<code>yield</code>发生时, 保存到栈上的context(即ctx 2), 但到当前这个时刻ctx 2指向的区域是无效的.</p><p>而方案B没有以上问题, 因为传递给<code>schedule</code>函数的<code>ctx</code>参数是保存在该task的内核栈上的, 栈上变量在函数的作用域内是有效的, 这是由C语言的机制保证的, <code>ctx</code>参数总是指向最近一次保存在内核栈上的context的地址.</p><h2 id="延申思考"><a href="#延申思考" class="headerlink" title="延申思考"></a>延申思考</h2><h3 id="idle-task"><a href="#idle-task" class="headerlink" title="idle task"></a>idle task</h3><p>之前在看Linux内核相关的资料时, 好像在哪看到了idle task这个说法, 一直没有理解这是个啥. 做完这个实验, 我好像有点懂了. <em>以下是个人理解.</em></p><p>以前玩单片机时, 程序里先是注册各种中断处理程序, 在最后面总是要加上 <code>while (1);</code>, 然后就开始响应各种中断. 这里的 <code>while (1);</code>其实就可以理解成idle task. CPU总是要干点什么, 即使只是死循环, 不然它就直接shutdown了.</p><p>操作系统代码也是一样, 在把所有资源初始化好之后, 它就退变为一个<strong>中断响应程序</strong>. 因此, 它也需要一个idle task, 以防止CPU shutdown. 当没有可运行的task可以调度执行时, 总是需要调度idle task到CPU上执行.</p><img src="/2021/05/04/threads-on-multi-CPU/image-20210504154530774.png" alt="image-20210504154530774" style="zoom:67%;"><h3 id="中断处理函数里不能休眠"><a href="#中断处理函数里不能休眠" class="headerlink" title="中断处理函数里不能休眠"></a>中断处理函数里不能休眠</h3><p>之前在看”Linux内核设计与实现”这本书时, 里面提到不能在中断上下文中调用会引起睡眠/阻塞的函数: <em>中断上下文和进程并没有什么瓜葛. 与current宏也是不相干的(尽管它会指向被中断的进程). 因为没有后备进程, 所以中断上下文不可以睡眠, 否则怎能再对它重新调度呢?</em>.我不太清楚Linux内核关于context的store/restore, 所以对这句话不是很理解.</p><p>根据我做完实验的理解, 睡眠即相当于主动调用<code>yield</code>, 让出CPU的执行权. 上文也分析了, 在当前的代码实现中, 在中断处理程序(handler function)里面调用<code>yield</code>, 根据实验现象来看, 无论是单CPU还是多CPU都是没有什么问题的. 还需要仔细思考这个问题.</p><h3 id="操作系统是一个并发程序"><a href="#操作系统是一个并发程序" class="headerlink" title="操作系统是一个并发程序"></a>操作系统是一个并发程序</h3><p>jyy在上课时总是在说这句话, 而且在课程安排上, 花了很多时间来讲并发, 和一些看起来和写操作系统代码无关的东西. 做完这个实验, 我又懂了.</p><p>当使用比如<code>POSIX threads</code>API创建线程时, 我们知道线程创建之后就会开始并发执行, 并且所有线程共享同一地址空间的全部内容, 比如全局/静态的数据. 每个线程都可以访问并修改全局变量, 并且修改后对其他线程也是可见的. 因此, 我们知道对于对于共享的数据, 需要使用锁保护起来, 比如<code>mutex</code>来提供互斥.</p><p>把视角切换回操作系统内核. CPU可以想象成上面提到的”线程”, 而操作系统内核代码可以想象成我们写的多线程程序. 因此, 所有的CPU执行的都是同一份代码, 代码里面所有的全局/静态数据, CPU都可以访问/修改, 并且修改后CPU之间也是可见的. 所以操作系统的代码里同样需要锁来保护共享的数据.</p><p>比如xv6的这段代码:</p><img src="/2021/05/04/threads-on-multi-CPU/image-20210504161404905.png" alt="image-20210504161404905" style="zoom:67%;"><p>CPU编号为0的CPU会执行<code>if</code>分支的代码, 其他所有的CPU执行<code>else</code>分支的代码. 由于内核里所有的全局数据都是共享的(比如文件系统相关的资源, 进程表等), 所以只需要由CPU0来初始化一次(当然可以由任意一个CPU来完成这个工作).   如果你足够细心, 你会发现上图中<code>else</code>分支里调用的函数都有<code>hart</code>后缀. 另外, 这里的<code>scheduler</code>也起到了前面提到的idle task的作用.</p><h3 id="硬件线程-hart"><a href="#硬件线程-hart" class="headerlink" title="硬件线程(hart)"></a>硬件线程(hart)</h3><p>通过阅读RISC-V的手册, 我得到了以下信息:</p><blockquote><p>hart是硬件线程(hardware thread)的缩略形式. 我们用该术语将它们与大多数程序员熟悉的软件线程区分开来. 软件线程在harts上进行分时复用. 大多数处理器核都只有一个hart.</p></blockquote><p>简单理解, 一个CPU*(我不太理解CPU与CPU core的区别, 这里把它们都称作CPU)*就是一个硬件线程(hart), 用户/内核创建的一个软件线程, 对应的就是CPU-local的tasks链表中的一个task.</p><p>此外, 我又想到了ADM的<del>县城</del>线程撕裂者:</p><img src="/2021/05/04/threads-on-multi-CPU/image-20210504164349104.png" alt="image-20210504164349104" style="zoom:67%;">]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;参考资料: &lt;a href=&quot;http://jyywiki.cn/OS/2021/labs/L2&quot;&gt;L2: 多处理器内核上的线程管理 (kmt) &lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;本文是在完成NJU操作系统</summary>
      
    
    
    
    <category term="NJU OS Lab" scheme="https://ysln.github.io/categories/NJU-OS-Lab/"/>
    
    
    <category term="C" scheme="https://ysln.github.io/tags/C/"/>
    
    <category term="OS" scheme="https://ysln.github.io/tags/OS/"/>
    
    <category term="thread" scheme="https://ysln.github.io/tags/thread/"/>
    
    <category term="hart" scheme="https://ysln.github.io/tags/hart/"/>
    
  </entry>
  
  <entry>
    <title>C语言实现Real-Eval-Print-Loop (REPL)</title>
    <link href="https://ysln.github.io/2021/05/01/crepl/"/>
    <id>https://ysln.github.io/2021/05/01/crepl/</id>
    <published>2021-05-01T07:11:46.598Z</published>
    <updated>2021-05-04T08:56:59.277Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em><strong>参考资料: <a href="http://jyywiki.cn/OS/2021/labs/M4">M4: C Real-Eval-Print-Loop (crepl)</a></strong></em></p><p>本文是在完成NJU操作系统实验过程中的一些记录.</p></blockquote><p>很多现代编程语言都提供了交互式的REPL, 比如Python. 在REPL中, 除了进行简单的数值计算外(类似计算器), 还可以动态创建函数, 并在之后调用它. 基于”解释执行”的程序设计语言(包括shell本身)天生就具有这种交互式的工作模式.</p><p>这个实验的目的是使用C语言实现一个简易的REPL. 最终效果如下:</p><img src="/2021/05/01/crepl/image-20210501112153656.png" alt="image-20210501112153656" style="zoom: 67%;"><p><em><strong>这个技术和现代虚拟机中的即时编译 (just-in-time) 技术是非常相关的：在程序运行时 (而非程序执行前) 进行编译，并将编译得到的二进制代码 (指令/数据) 动态加载。</strong></em> — 摘自<a href="http://jyywiki.cn/OS/2021/labs/M4">jyy的实验指南</a>.</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>C语言是一种编译型的语言, 源文件到二进制文件需要经过编译和链接(link)两个过程. 链接主要完成的工作是<strong>符号解析</strong>和<strong>重定位</strong>. </p><p>如果是静态链接的程序(<code>-static</code>), 类型为”Executable file(EXEC)”,  即<strong>可执行文件</strong>. 程序中的所有符号都是被完全解析的, 比如所有函数符号的地址都是确定的, 可以直接调用.</p><p>GCC默认生成的二进制文件是动态链接的,  生成的文件文件类型为”Shared object file(DYN)”. 一个动态链接的程序从磁盘(disk)上刚加载出来时是**不完整(部分链接)**的, 比如程序调用的位于glibc动态链接库中的<code>printf</code>函数地址是未知的. 内核(加载器)不能立即把控制权交给该程序(即跳转到<code>entry</code>). 因此, 需要另外的辅助程序(helper program)的帮助 ——– <strong>dynamic linker</strong>, (一般是ld.so). 它的任务是: <strong>加载程序依赖的DSOs(动态链接库, 比如glibc), 并完成重定位(<code>relocation</code>)</strong>.</p><p>因此, 要想实现一个交互式的REPL, 在程序运行时动态的在其地址空间内加入新的函数符号, 本质上是实现动态链接器的功能.</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>C语言实现的REPL的工作流程如下:</p><ol><li>读取用户的输入.</li><li>把输入的内容写入一个临时的源文件, 并把其编译成一个动态链接库.</li><li>把动态链接库加载到进程的地址空间.</li><li>计算用户输入的表达式, 输出结果.</li><li>重复上述步骤.</li></ol><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><img src="/2021/05/01/crepl/image-20210504125129936.png" alt="image-20210504125129936" style="zoom:67%;"><p>这里有以下注意事项:</p><ul><li><p>如果用户输入不是函数, 而是表达式, 比如”5 + 6”, 该怎么办? 一个很自然(看完jyy的实验指南后确实很自然…)的想法是把表达式”包装(wrap)”成一个函数, 比如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __wrap_func() &#123; <span class="keyword">return</span> <span class="number">5</span> + <span class="number">6</span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>这里实现”即时编译”的方法是<code>fork</code>一个子进程, 让子进程执行GCC, 主要是<code>exec</code>函数族(l, v, p, e的组合)的使用, 要注意<code>argv[0]</code>需要为可执行文件的名字.  注意这里把子进程的标准输出和标错误都关闭了, 防止gcc的输出影响.</p><p>这里还有一点是如果用户输入”f() + 6”, 那么源文件的内容为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __wrap_func() &#123; <span class="keyword">return</span> f() + <span class="number">6</span>;&#125;</span><br></pre></td></tr></table></figure><p>此时gcc编译会给出警告: “f”未定义. 如果”f”在之前定义了, 那么这个警告就无关紧要. 就算”f”没有定义, 也没有关系, 可以把出错处理推迟到加载阶段.</p></li></ul><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><img src="/2021/05/01/crepl/image-20210501130905417.png" alt="image-20210501130905417" style="zoom:67%;"><p>可以使用<code>dlopen</code>在运行时加载一个so文件到当前进程的地址空间中. 这里需要注意<code>dlopen</code>的flag参数:</p><ul><li><p><code>RTLD_GLOBAL</code>是必不可少的, 其含义是: 当前加载的so中的符号对其他so可见, 也就是说之后加载的so符号解析时, 可以使用这个so中的符号. 与其相对的是<code>RTLD_LOCAL</code>. 如果去掉<code>RTLD_GLOBAL</code>, 会出现以下这种情况:</p><img src="/2021/05/01/crepl/image-20210501131258559.png" alt="image-20210501131258559" style="zoom:67%;"><p>注意表达式”f()”也会被”wrap”成一个函数, 并编译成so. </p></li><li><p><code>RTLD_NOW</code>也是必不可少的, 其含义是: 在加载so时就进行(函数)符号解析. 与之相对的是<code>RTLD_LAZY</code>, 表示对应的函数符号解析推迟到函数被调用时. </p><p>使用<code>RTLD_LAZY</code>参数有以下实验现象:</p><img src="/2021/05/01/crepl/image-20210501132200769.png" alt="image-20210501132200769" style="zoom:67%;"><img src="/2021/05/01/crepl/image-20210504122855560.png" alt="image-20210504122855560" style="zoom:67%;"><p>也就是说, 定义函数时<strong>可以</strong>使用<strong>当前还未定义</strong>的符号, <code>dlopen</code>时不会报错(因为不会进行符号解析). 但是调用时如果找不到对应的函数符号, 进程会直接crash, 结束运行.</p><p>而使用<code>RTLD_NOW</code>参数有以下实验现象:</p><img src="/2021/05/01/crepl/image-20210501132836648.png" alt="image-20210501132836648" style="zoom:67%;"><p>也就是说定义函数时<strong>不允许</strong>使用<strong>当前还未定义</strong>的符号, 也不能直接使用未定义的函数计算,  <code>dlopen</code>进行符号解析时就会出错. 因此, 这才是我们想要的行为.</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;参考资料: &lt;a href=&quot;http://jyywiki.cn/OS/2021/labs/M4&quot;&gt;M4: C Real-Eval-Print-Loop (crepl)&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;本文</summary>
      
    
    
    
    <category term="NJU OS Lab" scheme="https://ysln.github.io/categories/NJU-OS-Lab/"/>
    
    
    <category term="C" scheme="https://ysln.github.io/tags/C/"/>
    
    <category term="REPL" scheme="https://ysln.github.io/tags/REPL/"/>
    
    <category term="动态链接" scheme="https://ysln.github.io/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    
  </entry>
  
</feed>
